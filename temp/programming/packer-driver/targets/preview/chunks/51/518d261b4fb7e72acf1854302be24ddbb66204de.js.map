{"version":3,"sources":["file:///Users/chicmic/Documents/InhouseCOCOS/ZipExtractor/node_modules/pako/lib/zlib/deflate.js"],"names":["_cjsLoader","_req","__cjsMetaURL","_req0","_req1","_req2","_req3","url","define","exports","require","module","__filename","__dirname","utils","trees","adler32","crc32","msg","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","strm","errorCode","rank","f","zero","buf","len","length","flush_pending","s","state","pending","avail_out","arraySet","output","pending_buf","pending_out","next_out","total_out","flush_block_only","last","_tr_flush_block","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","window","wmask","w_mask","prev","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","n","m","more","str","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","_tr_tally","max_lazy_match","last_lit","deflate_slow","max_insert","prev_match","strategy","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","level","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","dyn_ltree","Buf16","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","deflateResetKeep","data_type","_tr_init","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","Buf8","deflateInit","deflate","old_flush","beg","val","text","hcrc","extra","name","comment","time","os","header","level_flags","charCodeAt","bstate","_tr_align","_tr_stored_block","deflateEnd","deflateSetDictionary","dictionary","dictLength","avail","next","tmpDict","deflateInfo","_cjsExports","_deflateInit","_deflateInit2","_deflateReset","_deflateResetKeep","_deflateSetHeader","_deflate","_deflateEnd","_deflateSetDictionary","_deflateInfo"],"mappings":";;;;;;;;;AAAOA,MAAAA,U;;AACkBC,MAAAA,I,iBAAhBC,Y;;AACgBC,MAAAA,K,iBAAhBD,Y;;AACgBE,MAAAA,K,iBAAhBF,Y;;AACgBG,MAAAA,K,iBAAhBH,Y;;AACgBI,MAAAA,K,iBAAhBJ,Y;;;8BAWHA,Y,GAAe,cAAYK,G;;AACjCP,MAAAA,UAAU,CAACQ,MAAX,CAAkBN,YAAlB,EAAgC,UAAUO,OAAV,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,UAApC,EAAgDC,SAAhD,EAA2D;AAC3F;AAGC,qBAJ0F,CAM1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAIC,KAAK,GAAKJ,OAAO,CAAC,iBAAD,CAArB;;AACA,YAAIK,KAAK,GAAKL,OAAO,CAAC,SAAD,CAArB;;AACA,YAAIM,OAAO,GAAGN,OAAO,CAAC,WAAD,CAArB;;AACA,YAAIO,KAAK,GAAKP,OAAO,CAAC,SAAD,CAArB;;AACA,YAAIQ,GAAG,GAAOR,OAAO,CAAC,YAAD,CAArB;AAEA;;AACA;;AAGA;;;AACA,YAAIS,UAAU,GAAQ,CAAtB;AACA,YAAIC,eAAe,GAAG,CAAtB,CArC0F,CAsC1F;;AACA,YAAIC,YAAY,GAAM,CAAtB;AACA,YAAIC,QAAQ,GAAU,CAAtB;AACA,YAAIC,OAAO,GAAW,CAAtB,CAzC0F,CA0C1F;;AAGA;AACD;AACA;;AACC,YAAIC,IAAI,GAAc,CAAtB;AACA,YAAIC,YAAY,GAAM,CAAtB,CAjD0F,CAkD1F;AACA;;AACA,YAAIC,cAAc,GAAI,CAAC,CAAvB;AACA,YAAIC,YAAY,GAAM,CAAC,CAAvB,CArD0F,CAsD1F;;AACA,YAAIC,WAAW,GAAO,CAAC,CAAvB,CAvD0F,CAwD1F;;AAGA;AACA;AACA;AACA;;AACA,YAAIC,qBAAqB,GAAG,CAAC,CAA7B;AAGA,YAAIC,UAAU,GAAc,CAA5B;AACA,YAAIC,cAAc,GAAU,CAA5B;AACA,YAAIC,KAAK,GAAmB,CAA5B;AACA,YAAIC,OAAO,GAAiB,CAA5B;AACA,YAAIC,kBAAkB,GAAM,CAA5B;AAEA;AACA;AACA;AACA;;AACA,YAAIC,SAAS,GAAe,CAA5B;AAGA;;AACA,YAAIC,UAAU,GAAI,CAAlB;AAEA;;AAGA,YAAIC,aAAa,GAAG,CAApB;AACA;;AACA,YAAIC,SAAS,GAAG,EAAhB;AACA;;AACA,YAAIC,aAAa,GAAG,CAApB;AAGA,YAAIC,YAAY,GAAI,EAApB;AACA;;AACA,YAAIC,QAAQ,GAAQ,GAApB;AACA;;AACA,YAAIC,OAAO,GAASD,QAAQ,GAAG,CAAX,GAAeD,YAAnC;AACA;;AACA,YAAIG,OAAO,GAAS,EAApB;AACA;;AACA,YAAIC,QAAQ,GAAQ,EAApB;AACA;;AACA,YAAIC,SAAS,GAAO,IAAIH,OAAJ,GAAc,CAAlC;AACA;;AACA,YAAII,QAAQ,GAAI,EAAhB;AACA;;AAEA,YAAIC,SAAS,GAAG,CAAhB;AACA,YAAIC,SAAS,GAAG,GAAhB;AACA,YAAIC,aAAa,GAAID,SAAS,GAAGD,SAAZ,GAAwB,CAA7C;AAEA,YAAIG,WAAW,GAAG,IAAlB;AAEA,YAAIC,UAAU,GAAG,EAAjB;AACA,YAAIC,WAAW,GAAG,EAAlB;AACA,YAAIC,UAAU,GAAG,EAAjB;AACA,YAAIC,aAAa,GAAG,EAApB;AACA,YAAIC,UAAU,GAAG,GAAjB;AACA,YAAIC,UAAU,GAAG,GAAjB;AACA,YAAIC,YAAY,GAAG,GAAnB;AAEA,YAAIC,YAAY,GAAQ,CAAxB;AAA2B;;AAC3B,YAAIC,aAAa,GAAO,CAAxB;AAA2B;;AAC3B,YAAIC,iBAAiB,GAAG,CAAxB;AAA2B;;AAC3B,YAAIC,cAAc,GAAM,CAAxB;AAA2B;;AAE3B,YAAIC,OAAO,GAAG,IAAd,CA9H0F,CA8HtE;;AAEpB,iBAASC,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8B;AAC5BD,UAAAA,IAAI,CAAC9C,GAAL,GAAWA,GAAG,CAAC+C,SAAD,CAAd;AACA,iBAAOA,SAAP;AACD;;AAED,iBAASC,IAAT,CAAcC,CAAd,EAAiB;AACf,iBAAO,CAAEA,CAAD,IAAO,CAAR,KAAeA,CAAD,GAAM,CAAN,GAAU,CAAV,GAAc,CAA5B,CAAP;AACD;;AAED,iBAASC,IAAT,CAAcC,GAAd,EAAmB;AAAE,cAAIC,GAAG,GAAGD,GAAG,CAACE,MAAd;;AAAsB,iBAAO,EAAED,GAAF,IAAS,CAAhB,EAAmB;AAAED,YAAAA,GAAG,CAACC,GAAD,CAAH,GAAW,CAAX;AAAe;AAAE;AAGjF;AACD;AACA;AACA;AACA;AACA;;;AACC,iBAASE,aAAT,CAAuBR,IAAvB,EAA6B;AAC3B,cAAIS,CAAC,GAAGT,IAAI,CAACU,KAAb,CAD2B,CAG3B;;AACA,cAAIJ,GAAG,GAAGG,CAAC,CAACE,OAAZ;;AACA,cAAIL,GAAG,GAAGN,IAAI,CAACY,SAAf,EAA0B;AACxBN,YAAAA,GAAG,GAAGN,IAAI,CAACY,SAAX;AACD;;AACD,cAAIN,GAAG,KAAK,CAAZ,EAAe;AAAE;AAAS;;AAE1BxD,UAAAA,KAAK,CAAC+D,QAAN,CAAeb,IAAI,CAACc,MAApB,EAA4BL,CAAC,CAACM,WAA9B,EAA2CN,CAAC,CAACO,WAA7C,EAA0DV,GAA1D,EAA+DN,IAAI,CAACiB,QAApE;AACAjB,UAAAA,IAAI,CAACiB,QAAL,IAAiBX,GAAjB;AACAG,UAAAA,CAAC,CAACO,WAAF,IAAiBV,GAAjB;AACAN,UAAAA,IAAI,CAACkB,SAAL,IAAkBZ,GAAlB;AACAN,UAAAA,IAAI,CAACY,SAAL,IAAkBN,GAAlB;AACAG,UAAAA,CAAC,CAACE,OAAF,IAAaL,GAAb;;AACA,cAAIG,CAAC,CAACE,OAAF,KAAc,CAAlB,EAAqB;AACnBF,YAAAA,CAAC,CAACO,WAAF,GAAgB,CAAhB;AACD;AACF;;AAGD,iBAASG,gBAAT,CAA0BV,CAA1B,EAA6BW,IAA7B,EAAmC;AACjCrE,UAAAA,KAAK,CAACsE,eAAN,CAAsBZ,CAAtB,EAA0BA,CAAC,CAACa,WAAF,IAAiB,CAAjB,GAAqBb,CAAC,CAACa,WAAvB,GAAqC,CAAC,CAAhE,EAAoEb,CAAC,CAACc,QAAF,GAAad,CAAC,CAACa,WAAnF,EAAgGF,IAAhG;;AACAX,UAAAA,CAAC,CAACa,WAAF,GAAgBb,CAAC,CAACc,QAAlB;AACAf,UAAAA,aAAa,CAACC,CAAC,CAACT,IAAH,CAAb;AACD;;AAGD,iBAASwB,QAAT,CAAkBf,CAAlB,EAAqBgB,CAArB,EAAwB;AACtBhB,UAAAA,CAAC,CAACM,WAAF,CAAcN,CAAC,CAACE,OAAF,EAAd,IAA6Bc,CAA7B;AACD;AAGD;AACD;AACA;AACA;AACA;;;AACC,iBAASC,WAAT,CAAqBjB,CAArB,EAAwBgB,CAAxB,EAA2B;AAC3B;AACA;AACEhB,UAAAA,CAAC,CAACM,WAAF,CAAcN,CAAC,CAACE,OAAF,EAAd,IAA8Bc,CAAC,KAAK,CAAP,GAAY,IAAzC;AACAhB,UAAAA,CAAC,CAACM,WAAF,CAAcN,CAAC,CAACE,OAAF,EAAd,IAA6Bc,CAAC,GAAG,IAAjC;AACD;AAGD;AACD;AACA;AACA;AACA;AACA;AACA;;;AACC,iBAASE,QAAT,CAAkB3B,IAAlB,EAAwBK,GAAxB,EAA6BuB,KAA7B,EAAoCC,IAApC,EAA0C;AACxC,cAAIvB,GAAG,GAAGN,IAAI,CAAC8B,QAAf;;AAEA,cAAIxB,GAAG,GAAGuB,IAAV,EAAgB;AAAEvB,YAAAA,GAAG,GAAGuB,IAAN;AAAa;;AAC/B,cAAIvB,GAAG,KAAK,CAAZ,EAAe;AAAE,mBAAO,CAAP;AAAW;;AAE5BN,UAAAA,IAAI,CAAC8B,QAAL,IAAiBxB,GAAjB,CANwC,CAQxC;;AACAxD,UAAAA,KAAK,CAAC+D,QAAN,CAAeR,GAAf,EAAoBL,IAAI,CAAC+B,KAAzB,EAAgC/B,IAAI,CAACgC,OAArC,EAA8C1B,GAA9C,EAAmDsB,KAAnD;;AACA,cAAI5B,IAAI,CAACU,KAAL,CAAWuB,IAAX,KAAoB,CAAxB,EAA2B;AACzBjC,YAAAA,IAAI,CAACkC,KAAL,GAAalF,OAAO,CAACgD,IAAI,CAACkC,KAAN,EAAa7B,GAAb,EAAkBC,GAAlB,EAAuBsB,KAAvB,CAApB;AACD,WAFD,MAIK,IAAI5B,IAAI,CAACU,KAAL,CAAWuB,IAAX,KAAoB,CAAxB,EAA2B;AAC9BjC,YAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAa7B,GAAb,EAAkBC,GAAlB,EAAuBsB,KAAvB,CAAlB;AACD;;AAED5B,UAAAA,IAAI,CAACgC,OAAL,IAAgB1B,GAAhB;AACAN,UAAAA,IAAI,CAACmC,QAAL,IAAiB7B,GAAjB;AAEA,iBAAOA,GAAP;AACD;AAGD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC,iBAAS8B,aAAT,CAAuB3B,CAAvB,EAA0B4B,SAA1B,EAAqC;AACnC,cAAIC,YAAY,GAAG7B,CAAC,CAAC8B,gBAArB;AAA4C;;AAC5C,cAAIC,IAAI,GAAG/B,CAAC,CAACc,QAAb;AAAuB;;AACvB,cAAIkB,KAAJ;AAAiC;;AACjC,cAAInC,GAAJ;AAAmC;;AACnC,cAAIoC,QAAQ,GAAGjC,CAAC,CAACkC,WAAjB;AAA2C;;AAC3C,cAAIC,UAAU,GAAGnC,CAAC,CAACmC,UAAnB;AAA2C;;AAC3C,cAAIC,KAAK,GAAIpC,CAAC,CAACc,QAAF,GAAcd,CAAC,CAACqC,MAAF,GAAW7D,aAA1B,GACRwB,CAAC,CAACc,QAAF,IAAcd,CAAC,CAACqC,MAAF,GAAW7D,aAAzB,CADQ,GACkC;AAAC;AAD/C;AAGA,cAAI8D,IAAI,GAAGtC,CAAC,CAACuC,MAAb,CAVmC,CAUd;;AAErB,cAAIC,KAAK,GAAGxC,CAAC,CAACyC,MAAd;AACA,cAAIC,IAAI,GAAI1C,CAAC,CAAC0C,IAAd;AAEA;AACH;AACA;;AAEG,cAAIC,MAAM,GAAG3C,CAAC,CAACc,QAAF,GAAavC,SAA1B;AACA,cAAIqE,SAAS,GAAIN,IAAI,CAACP,IAAI,GAAGE,QAAP,GAAkB,CAAnB,CAArB;AACA,cAAIY,QAAQ,GAAKP,IAAI,CAACP,IAAI,GAAGE,QAAR,CAArB;AAEA;AACH;AACA;AACG;;AAEA;;AACA,cAAIjC,CAAC,CAACkC,WAAF,IAAiBlC,CAAC,CAAC8C,UAAvB,EAAmC;AACjCjB,YAAAA,YAAY,KAAK,CAAjB;AACD;AACD;AACH;AACA;;;AACG,cAAIM,UAAU,GAAGnC,CAAC,CAAC+C,SAAnB,EAA8B;AAAEZ,YAAAA,UAAU,GAAGnC,CAAC,CAAC+C,SAAf;AAA2B,WAnCxB,CAqCnC;;;AAEA,aAAG;AACD;AACAf,YAAAA,KAAK,GAAGJ,SAAR;AAEA;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEK,gBAAIU,IAAI,CAACN,KAAK,GAAGC,QAAT,CAAJ,KAA+BY,QAA/B,IACAP,IAAI,CAACN,KAAK,GAAGC,QAAR,GAAmB,CAApB,CAAJ,KAA+BW,SAD/B,IAEAN,IAAI,CAACN,KAAD,CAAJ,KAA+BM,IAAI,CAACP,IAAD,CAFnC,IAGAO,IAAI,CAAC,EAAEN,KAAH,CAAJ,KAA+BM,IAAI,CAACP,IAAI,GAAG,CAAR,CAHvC,EAGmD;AACjD;AACD;AAED;AACL;AACA;AACA;AACA;AACA;;;AACKA,YAAAA,IAAI,IAAI,CAAR;AACAC,YAAAA,KAAK,GA3BJ,CA4BD;;AAEA;AACL;AACA;;AACK,eAAG;AACD;AACD,aAFD,QAESM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CAArB,IAAkCM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CAAvD,IACAM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CADrB,IACkCM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CADvD,IAEAM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CAFrB,IAEkCM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CAFvD,IAGAM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CAHrB,IAGkCM,IAAI,CAAC,EAAEP,IAAH,CAAJ,KAAiBO,IAAI,CAAC,EAAEN,KAAH,CAHvD,IAIAD,IAAI,GAAGY,MANhB,EAjCC,CAyCD;;;AAEA9C,YAAAA,GAAG,GAAGtB,SAAS,IAAIoE,MAAM,GAAGZ,IAAb,CAAf;AACAA,YAAAA,IAAI,GAAGY,MAAM,GAAGpE,SAAhB;;AAEA,gBAAIsB,GAAG,GAAGoC,QAAV,EAAoB;AAClBjC,cAAAA,CAAC,CAACgD,WAAF,GAAgBpB,SAAhB;AACAK,cAAAA,QAAQ,GAAGpC,GAAX;;AACA,kBAAIA,GAAG,IAAIsC,UAAX,EAAuB;AACrB;AACD;;AACDS,cAAAA,SAAS,GAAIN,IAAI,CAACP,IAAI,GAAGE,QAAP,GAAkB,CAAnB,CAAjB;AACAY,cAAAA,QAAQ,GAAKP,IAAI,CAACP,IAAI,GAAGE,QAAR,CAAjB;AACD;AACF,WAvDD,QAuDS,CAACL,SAAS,GAAGc,IAAI,CAACd,SAAS,GAAGY,KAAb,CAAjB,IAAwCJ,KAAxC,IAAiD,EAAEP,YAAF,KAAmB,CAvD7E;;AAyDA,cAAII,QAAQ,IAAIjC,CAAC,CAAC+C,SAAlB,EAA6B;AAC3B,mBAAOd,QAAP;AACD;;AACD,iBAAOjC,CAAC,CAAC+C,SAAT;AACD;AAGD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC,iBAASE,WAAT,CAAqBjD,CAArB,EAAwB;AACtB,cAAIkD,OAAO,GAAGlD,CAAC,CAACqC,MAAhB;AACA,cAAIc,CAAJ,EAAOC,CAAP,EAAUC,CAAV,EAAaC,IAAb,EAAmBC,GAAnB,CAFsB,CAItB;;AAEA,aAAG;AACDD,YAAAA,IAAI,GAAGtD,CAAC,CAACwD,WAAF,GAAgBxD,CAAC,CAAC+C,SAAlB,GAA8B/C,CAAC,CAACc,QAAvC,CADC,CAGD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACL;AACA;;AACK,gBAAId,CAAC,CAACc,QAAF,IAAcoC,OAAO,IAAIA,OAAO,GAAG1E,aAAd,CAAzB,EAAuD;AAErDnC,cAAAA,KAAK,CAAC+D,QAAN,CAAeJ,CAAC,CAACuC,MAAjB,EAAyBvC,CAAC,CAACuC,MAA3B,EAAmCW,OAAnC,EAA4CA,OAA5C,EAAqD,CAArD;AACAlD,cAAAA,CAAC,CAACgD,WAAF,IAAiBE,OAAjB;AACAlD,cAAAA,CAAC,CAACc,QAAF,IAAcoC,OAAd;AACA;;AACAlD,cAAAA,CAAC,CAACa,WAAF,IAAiBqC,OAAjB;AAEA;AACP;AACA;AACA;AACA;AACA;;AAEOE,cAAAA,CAAC,GAAGpD,CAAC,CAACyD,SAAN;AACAN,cAAAA,CAAC,GAAGC,CAAJ;;AACA,iBAAG;AACDC,gBAAAA,CAAC,GAAGrD,CAAC,CAAC0D,IAAF,CAAO,EAAEP,CAAT,CAAJ;AACAnD,gBAAAA,CAAC,CAAC0D,IAAF,CAAOP,CAAP,IAAaE,CAAC,IAAIH,OAAL,GAAeG,CAAC,GAAGH,OAAnB,GAA6B,CAA1C;AACD,eAHD,QAGS,EAAEE,CAHX;;AAKAA,cAAAA,CAAC,GAAGF,OAAJ;AACAC,cAAAA,CAAC,GAAGC,CAAJ;;AACA,iBAAG;AACDC,gBAAAA,CAAC,GAAGrD,CAAC,CAAC0C,IAAF,CAAO,EAAES,CAAT,CAAJ;AACAnD,gBAAAA,CAAC,CAAC0C,IAAF,CAAOS,CAAP,IAAaE,CAAC,IAAIH,OAAL,GAAeG,CAAC,GAAGH,OAAnB,GAA6B,CAA1C;AACA;AACT;AACA;AACQ,eAND,QAMS,EAAEE,CANX;;AAQAE,cAAAA,IAAI,IAAIJ,OAAR;AACD;;AACD,gBAAIlD,CAAC,CAACT,IAAF,CAAO8B,QAAP,KAAoB,CAAxB,EAA2B;AACzB;AACD;AAED;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACK;;;AACA+B,YAAAA,CAAC,GAAGlC,QAAQ,CAAClB,CAAC,CAACT,IAAH,EAASS,CAAC,CAACuC,MAAX,EAAmBvC,CAAC,CAACc,QAAF,GAAad,CAAC,CAAC+C,SAAlC,EAA6CO,IAA7C,CAAZ;AACAtD,YAAAA,CAAC,CAAC+C,SAAF,IAAeK,CAAf;AAEA;;AACA,gBAAIpD,CAAC,CAAC+C,SAAF,GAAc/C,CAAC,CAAC2D,MAAhB,IAA0BrF,SAA9B,EAAyC;AACvCiF,cAAAA,GAAG,GAAGvD,CAAC,CAACc,QAAF,GAAad,CAAC,CAAC2D,MAArB;AACA3D,cAAAA,CAAC,CAAC4D,KAAF,GAAU5D,CAAC,CAACuC,MAAF,CAASgB,GAAT,CAAV;AAEA;;AACAvD,cAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASgB,GAAG,GAAG,CAAf,CAA7B,IAAkDvD,CAAC,CAAC8D,SAA9D,CALuC,CAM7C;AACA;AACA;;AACM,qBAAO9D,CAAC,CAAC2D,MAAT,EAAiB;AACf;AACA3D,gBAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASgB,GAAG,GAAGjF,SAAN,GAAkB,CAA3B,CAA7B,IAA8D0B,CAAC,CAAC8D,SAA1E;AAEA9D,gBAAAA,CAAC,CAAC0C,IAAF,CAAOa,GAAG,GAAGvD,CAAC,CAACyC,MAAf,IAAyBzC,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,CAAzB;AACA5D,gBAAAA,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,IAAkBL,GAAlB;AACAA,gBAAAA,GAAG;AACHvD,gBAAAA,CAAC,CAAC2D,MAAF;;AACA,oBAAI3D,CAAC,CAAC+C,SAAF,GAAc/C,CAAC,CAAC2D,MAAhB,GAAyBrF,SAA7B,EAAwC;AACtC;AACD;AACF;AACF;AACD;AACL;AACA;;AAEI,WArGD,QAqGS0B,CAAC,CAAC+C,SAAF,GAAcvE,aAAd,IAA+BwB,CAAC,CAACT,IAAF,CAAO8B,QAAP,KAAoB,CArG5D;AAuGA;AACH;AACA;AACA;AACA;AACA;AACA;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACC;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC,iBAAS0C,cAAT,CAAwB/D,CAAxB,EAA2BgE,KAA3B,EAAkC;AAChC;AACH;AACA;AACG,cAAIC,cAAc,GAAG,MAArB;;AAEA,cAAIA,cAAc,GAAGjE,CAAC,CAACkE,gBAAF,GAAqB,CAA1C,EAA6C;AAC3CD,YAAAA,cAAc,GAAGjE,CAAC,CAACkE,gBAAF,GAAqB,CAAtC;AACD;AAED;;;AACA,mBAAS;AACP;AACA,gBAAIlE,CAAC,CAAC+C,SAAF,IAAe,CAAnB,EAAsB;AAEpB;AACA;AACN;AACA;AACA;AACA;AAEME,cAAAA,WAAW,CAACjD,CAAD,CAAX;;AACA,kBAAIA,CAAC,CAAC+C,SAAF,KAAgB,CAAhB,IAAqBiB,KAAK,KAAKtH,UAAnC,EAA+C;AAC7C,uBAAOuC,YAAP;AACD;;AAED,kBAAIe,CAAC,CAAC+C,SAAF,KAAgB,CAApB,EAAuB;AACrB;AACD;AACD;;AACD,aApBM,CAqBP;AACJ;;;AAEI/C,YAAAA,CAAC,CAACc,QAAF,IAAcd,CAAC,CAAC+C,SAAhB;AACA/C,YAAAA,CAAC,CAAC+C,SAAF,GAAc,CAAd;AAEA;;AACA,gBAAIoB,SAAS,GAAGnE,CAAC,CAACa,WAAF,GAAgBoD,cAAhC;;AAEA,gBAAIjE,CAAC,CAACc,QAAF,KAAe,CAAf,IAAoBd,CAAC,CAACc,QAAF,IAAcqD,SAAtC,EAAiD;AAC/C;AACAnE,cAAAA,CAAC,CAAC+C,SAAF,GAAc/C,CAAC,CAACc,QAAF,GAAaqD,SAA3B;AACAnE,cAAAA,CAAC,CAACc,QAAF,GAAaqD,SAAb;AACA;;AACAzD,cAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,kBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,uBAAOlB,YAAP;AACD;AACD;;AAGD;AACD;AACL;AACA;;;AACK,gBAAIe,CAAC,CAACc,QAAF,GAAad,CAAC,CAACa,WAAf,IAA+Bb,CAAC,CAACqC,MAAF,GAAW7D,aAA9C,EAA8D;AAC5D;AACAkC,cAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,kBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,uBAAOlB,YAAP;AACD;AACD;;AACD;AACF;;AAEDe,UAAAA,CAAC,CAAC2D,MAAF,GAAW,CAAX;;AAEA,cAAIK,KAAK,KAAKnH,QAAd,EAAwB;AACtB;AACA6D,YAAAA,gBAAgB,CAACV,CAAD,EAAI,IAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOhB,iBAAP;AACD;AACD;;;AACA,mBAAOC,cAAP;AACD;;AAED,cAAIY,CAAC,CAACc,QAAF,GAAad,CAAC,CAACa,WAAnB,EAAgC;AAC9B;AACAH,YAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOlB,YAAP;AACD;AACD;;AACD;;AAED,iBAAOA,YAAP;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACC,iBAASmF,YAAT,CAAsBpE,CAAtB,EAAyBgE,KAAzB,EAAgC;AAC9B,cAAIK,SAAJ;AAAsB;;AACtB,cAAIC,MAAJ;AAAsB;;AAEtB,mBAAS;AACP;AACL;AACA;AACA;AACA;AACK,gBAAItE,CAAC,CAAC+C,SAAF,GAAcvE,aAAlB,EAAiC;AAC/ByE,cAAAA,WAAW,CAACjD,CAAD,CAAX;;AACA,kBAAIA,CAAC,CAAC+C,SAAF,GAAcvE,aAAd,IAA+BwF,KAAK,KAAKtH,UAA7C,EAAyD;AACvD,uBAAOuC,YAAP;AACD;;AACD,kBAAIe,CAAC,CAAC+C,SAAF,KAAgB,CAApB,EAAuB;AACrB;AAAO;AACR;AACF;AAED;AACL;AACA;;;AACKsB,YAAAA,SAAS,GAAG;AAAC;AAAb;;AACA,gBAAIrE,CAAC,CAAC+C,SAAF,IAAezE,SAAnB,EAA8B;AAC5B;AACA0B,cAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAF,GAAaxC,SAAb,GAAyB,CAAlC,CAA7B,IAAqE0B,CAAC,CAAC8D,SAAjF;AACAO,cAAAA,SAAS,GAAGrE,CAAC,CAAC0C,IAAF,CAAO1C,CAAC,CAACc,QAAF,GAAad,CAAC,CAACyC,MAAtB,IAAgCzC,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,CAA5C;AACA5D,cAAAA,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,IAAkB5D,CAAC,CAACc,QAApB;AACA;AACD;AAED;AACL;AACA;;;AACK,gBAAIuD,SAAS,KAAK;AAAC;AAAf,eAA4BrE,CAAC,CAACc,QAAF,GAAauD,SAAd,IAA6BrE,CAAC,CAACqC,MAAF,GAAW7D,aAAvE,EAAwF;AACtF;AACP;AACA;AACA;AACOwB,cAAAA,CAAC,CAACuE,YAAF,GAAiB5C,aAAa,CAAC3B,CAAD,EAAIqE,SAAJ,CAA9B;AACA;AACD;;AACD,gBAAIrE,CAAC,CAACuE,YAAF,IAAkBjG,SAAtB,EAAiC;AAC/B;;AAEA;AACP;AACOgG,cAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmBA,CAAC,CAACc,QAAF,GAAad,CAAC,CAACgD,WAAlC,EAA+ChD,CAAC,CAACuE,YAAF,GAAiBjG,SAAhE,CAAT;AAEA0B,cAAAA,CAAC,CAAC+C,SAAF,IAAe/C,CAAC,CAACuE,YAAjB;AAEA;AACP;AACA;;AACO,kBAAIvE,CAAC,CAACuE,YAAF,IAAkBvE,CAAC,CAACyE;AAAc;AAAlC,iBAA2DzE,CAAC,CAAC+C,SAAF,IAAezE,SAA9E,EAAyF;AACvF0B,gBAAAA,CAAC,CAACuE,YAAF;AAAkB;;AAClB,mBAAG;AACDvE,kBAAAA,CAAC,CAACc,QAAF;AACA;;AACAd,kBAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAF,GAAaxC,SAAb,GAAyB,CAAlC,CAA7B,IAAqE0B,CAAC,CAAC8D,SAAjF;AACAO,kBAAAA,SAAS,GAAGrE,CAAC,CAAC0C,IAAF,CAAO1C,CAAC,CAACc,QAAF,GAAad,CAAC,CAACyC,MAAtB,IAAgCzC,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,CAA5C;AACA5D,kBAAAA,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,IAAkB5D,CAAC,CAACc,QAApB;AACA;;AACA;AACX;AACA;AACU,iBAVD,QAUS,EAAEd,CAAC,CAACuE,YAAJ,KAAqB,CAV9B;;AAWAvE,gBAAAA,CAAC,CAACc,QAAF;AACD,eAdD,MAeA;AACEd,gBAAAA,CAAC,CAACc,QAAF,IAAcd,CAAC,CAACuE,YAAhB;AACAvE,gBAAAA,CAAC,CAACuE,YAAF,GAAiB,CAAjB;AACAvE,gBAAAA,CAAC,CAAC4D,KAAF,GAAU5D,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAX,CAAV;AACA;;AACAd,gBAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAF,GAAa,CAAtB,CAA7B,IAAyDd,CAAC,CAAC8D,SAArE,CALF,CAON;AACA;AACA;;AACQ;AACT;AACA;AACQ;AACF,aAzCD,MAyCO;AACL;AACA;;AACA;AACAQ,cAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmB,CAAnB,EAAsBA,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAX,CAAtB,CAAT;AAEAd,cAAAA,CAAC,CAAC+C,SAAF;AACA/C,cAAAA,CAAC,CAACc,QAAF;AACD;;AACD,gBAAIwD,MAAJ,EAAY;AACV;AACA5D,cAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,kBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,uBAAOlB,YAAP;AACD;AACD;;AACD;AACF;;AACDe,UAAAA,CAAC,CAAC2D,MAAF,GAAa3D,CAAC,CAACc,QAAF,GAAcxC,SAAS,GAAG,CAA3B,GAAiC0B,CAAC,CAACc,QAAnC,GAA8CxC,SAAS,GAAG,CAAtE;;AACA,cAAI0F,KAAK,KAAKnH,QAAd,EAAwB;AACtB;AACA6D,YAAAA,gBAAgB,CAACV,CAAD,EAAI,IAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOhB,iBAAP;AACD;AACD;;;AACA,mBAAOC,cAAP;AACD;;AACD,cAAIY,CAAC,CAAC0E,QAAN,EAAgB;AACd;AACAhE,YAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOlB,YAAP;AACD;AACD;;AACD;;AACD,iBAAOC,aAAP;AACD;AAED;AACD;AACA;AACA;AACA;;;AACC,iBAASyF,YAAT,CAAsB3E,CAAtB,EAAyBgE,KAAzB,EAAgC;AAC9B,cAAIK,SAAJ;AAAwB;;AACxB,cAAIC,MAAJ;AAAyB;;AAEzB,cAAIM,UAAJ;AAEA;;AACA,mBAAS;AACP;AACL;AACA;AACA;AACA;AACK,gBAAI5E,CAAC,CAAC+C,SAAF,GAAcvE,aAAlB,EAAiC;AAC/ByE,cAAAA,WAAW,CAACjD,CAAD,CAAX;;AACA,kBAAIA,CAAC,CAAC+C,SAAF,GAAcvE,aAAd,IAA+BwF,KAAK,KAAKtH,UAA7C,EAAyD;AACvD,uBAAOuC,YAAP;AACD;;AACD,kBAAIe,CAAC,CAAC+C,SAAF,KAAgB,CAApB,EAAuB;AAAE;AAAQ;AAAC;;AACnC;AAED;AACL;AACA;;;AACKsB,YAAAA,SAAS,GAAG;AAAC;AAAb;;AACA,gBAAIrE,CAAC,CAAC+C,SAAF,IAAezE,SAAnB,EAA8B;AAC5B;AACA0B,cAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAF,GAAaxC,SAAb,GAAyB,CAAlC,CAA7B,IAAqE0B,CAAC,CAAC8D,SAAjF;AACAO,cAAAA,SAAS,GAAGrE,CAAC,CAAC0C,IAAF,CAAO1C,CAAC,CAACc,QAAF,GAAad,CAAC,CAACyC,MAAtB,IAAgCzC,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,CAA5C;AACA5D,cAAAA,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,IAAkB5D,CAAC,CAACc,QAApB;AACA;AACD;AAED;AACL;;;AACKd,YAAAA,CAAC,CAACkC,WAAF,GAAgBlC,CAAC,CAACuE,YAAlB;AACAvE,YAAAA,CAAC,CAAC6E,UAAF,GAAe7E,CAAC,CAACgD,WAAjB;AACAhD,YAAAA,CAAC,CAACuE,YAAF,GAAiBjG,SAAS,GAAG,CAA7B;;AAEA,gBAAI+F,SAAS,KAAK;AAAC;AAAf,eAA0BrE,CAAC,CAACkC,WAAF,GAAgBlC,CAAC,CAACyE,cAA5C,IACAzE,CAAC,CAACc,QAAF,GAAauD,SAAb,IAA2BrE,CAAC,CAACqC,MAAF,GAAW7D;AAAc;AADxD,cACyE;AACvE;AACP;AACA;AACA;AACOwB,cAAAA,CAAC,CAACuE,YAAF,GAAiB5C,aAAa,CAAC3B,CAAD,EAAIqE,SAAJ,CAA9B;AACA;;AAEA,kBAAIrE,CAAC,CAACuE,YAAF,IAAkB,CAAlB,KACAvE,CAAC,CAAC8E,QAAF,KAAezH,UAAf,IAA8B2C,CAAC,CAACuE,YAAF,KAAmBjG,SAAnB,IAAgC0B,CAAC,CAACc,QAAF,GAAad,CAAC,CAACgD,WAAf,GAA6B;AAAI;AAD/F,eAAJ,EACkH;AAEhH;AACT;AACA;AACShD,gBAAAA,CAAC,CAACuE,YAAF,GAAiBjG,SAAS,GAAG,CAA7B;AACD;AACF;AACD;AACL;AACA;;;AACK,gBAAI0B,CAAC,CAACkC,WAAF,IAAiB5D,SAAjB,IAA8B0B,CAAC,CAACuE,YAAF,IAAkBvE,CAAC,CAACkC,WAAtD,EAAmE;AACjE0C,cAAAA,UAAU,GAAG5E,CAAC,CAACc,QAAF,GAAad,CAAC,CAAC+C,SAAf,GAA2BzE,SAAxC;AACA;AAEA;;AAEA;AACP;;AACOgG,cAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmBA,CAAC,CAACc,QAAF,GAAa,CAAb,GAAiBd,CAAC,CAAC6E,UAAtC,EAAkD7E,CAAC,CAACkC,WAAF,GAAgB5D,SAAlE,CAAT;AACA;AACP;AACA;AACA;AACA;;AACO0B,cAAAA,CAAC,CAAC+C,SAAF,IAAe/C,CAAC,CAACkC,WAAF,GAAgB,CAA/B;AACAlC,cAAAA,CAAC,CAACkC,WAAF,IAAiB,CAAjB;;AACA,iBAAG;AACD,oBAAI,EAAElC,CAAC,CAACc,QAAJ,IAAgB8D,UAApB,EAAgC;AAC9B;AACA5E,kBAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAF,GAAaxC,SAAb,GAAyB,CAAlC,CAA7B,IAAqE0B,CAAC,CAAC8D,SAAjF;AACAO,kBAAAA,SAAS,GAAGrE,CAAC,CAAC0C,IAAF,CAAO1C,CAAC,CAACc,QAAF,GAAad,CAAC,CAACyC,MAAtB,IAAgCzC,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,CAA5C;AACA5D,kBAAAA,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,IAAkB5D,CAAC,CAACc,QAApB;AACA;AACD;AACF,eARD,QAQS,EAAEd,CAAC,CAACkC,WAAJ,KAAoB,CAR7B;;AASAlC,cAAAA,CAAC,CAAC+E,eAAF,GAAoB,CAApB;AACA/E,cAAAA,CAAC,CAACuE,YAAF,GAAiBjG,SAAS,GAAG,CAA7B;AACA0B,cAAAA,CAAC,CAACc,QAAF;;AAEA,kBAAIwD,MAAJ,EAAY;AACV;AACA5D,gBAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,oBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,yBAAOlB,YAAP;AACD;AACD;;AACD;AAEF,aAtCD,MAsCO,IAAIe,CAAC,CAAC+E,eAAN,EAAuB;AAC5B;AACP;AACA;AACA;AACO;;AACA;AACAT,cAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmB,CAAnB,EAAsBA,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAF,GAAa,CAAtB,CAAtB,CAAT;;AAEA,kBAAIwD,MAAJ,EAAY;AACV;AACA5D,gBAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;AACA;AACD;;AACDA,cAAAA,CAAC,CAACc,QAAF;AACAd,cAAAA,CAAC,CAAC+C,SAAF;;AACA,kBAAI/C,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,uBAAOlB,YAAP;AACD;AACF,aAnBM,MAmBA;AACL;AACP;AACA;AACOe,cAAAA,CAAC,CAAC+E,eAAF,GAAoB,CAApB;AACA/E,cAAAA,CAAC,CAACc,QAAF;AACAd,cAAAA,CAAC,CAAC+C,SAAF;AACD;AACF,WA7H6B,CA8H9B;;;AACA,cAAI/C,CAAC,CAAC+E,eAAN,EAAuB;AACrB;;AACA;AACAT,YAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmB,CAAnB,EAAsBA,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAF,GAAa,CAAtB,CAAtB,CAAT;AAEAd,YAAAA,CAAC,CAAC+E,eAAF,GAAoB,CAApB;AACD;;AACD/E,UAAAA,CAAC,CAAC2D,MAAF,GAAW3D,CAAC,CAACc,QAAF,GAAaxC,SAAS,GAAG,CAAzB,GAA6B0B,CAAC,CAACc,QAA/B,GAA0CxC,SAAS,GAAG,CAAjE;;AACA,cAAI0F,KAAK,KAAKnH,QAAd,EAAwB;AACtB;AACA6D,YAAAA,gBAAgB,CAACV,CAAD,EAAI,IAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOhB,iBAAP;AACD;AACD;;;AACA,mBAAOC,cAAP;AACD;;AACD,cAAIY,CAAC,CAAC0E,QAAN,EAAgB;AACd;AACAhE,YAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOlB,YAAP;AACD;AACD;;AACD;;AAED,iBAAOC,aAAP;AACD;AAGD;AACD;AACA;AACA;AACA;;;AACC,iBAAS8F,WAAT,CAAqBhF,CAArB,EAAwBgE,KAAxB,EAA+B;AAC7B,cAAIM,MAAJ;AAAuB;;AACvB,cAAI5B,IAAJ;AAAuB;;AACvB,cAAIX,IAAJ,EAAUY,MAAV;AAAuB;;AAEvB,cAAIL,IAAI,GAAGtC,CAAC,CAACuC,MAAb;;AAEA,mBAAS;AACP;AACL;AACA;AACA;AACK,gBAAIvC,CAAC,CAAC+C,SAAF,IAAexE,SAAnB,EAA8B;AAC5B0E,cAAAA,WAAW,CAACjD,CAAD,CAAX;;AACA,kBAAIA,CAAC,CAAC+C,SAAF,IAAexE,SAAf,IAA4ByF,KAAK,KAAKtH,UAA1C,EAAsD;AACpD,uBAAOuC,YAAP;AACD;;AACD,kBAAIe,CAAC,CAAC+C,SAAF,KAAgB,CAApB,EAAuB;AAAE;AAAQ;AAAC;;AACnC;AAED;;;AACA/C,YAAAA,CAAC,CAACuE,YAAF,GAAiB,CAAjB;;AACA,gBAAIvE,CAAC,CAAC+C,SAAF,IAAezE,SAAf,IAA4B0B,CAAC,CAACc,QAAF,GAAa,CAA7C,EAAgD;AAC9CiB,cAAAA,IAAI,GAAG/B,CAAC,CAACc,QAAF,GAAa,CAApB;AACA4B,cAAAA,IAAI,GAAGJ,IAAI,CAACP,IAAD,CAAX;;AACA,kBAAIW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAAb,IAAyBW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAAtC,IAAkDW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAAnE,EAA6E;AAC3EY,gBAAAA,MAAM,GAAG3C,CAAC,CAACc,QAAF,GAAavC,SAAtB;;AACA,mBAAG;AACD;AACD,iBAFD,QAESmE,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAAb,IAAyBW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAAtC,IACAW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CADb,IACyBW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CADtC,IAEAW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAFb,IAEyBW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAFtC,IAGAW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAHb,IAGyBW,IAAI,KAAKJ,IAAI,CAAC,EAAEP,IAAH,CAHtC,IAIAA,IAAI,GAAGY,MANhB;;AAOA3C,gBAAAA,CAAC,CAACuE,YAAF,GAAiBhG,SAAS,IAAIoE,MAAM,GAAGZ,IAAb,CAA1B;;AACA,oBAAI/B,CAAC,CAACuE,YAAF,GAAiBvE,CAAC,CAAC+C,SAAvB,EAAkC;AAChC/C,kBAAAA,CAAC,CAACuE,YAAF,GAAiBvE,CAAC,CAAC+C,SAAnB;AACD;AACF,eAhB6C,CAiB9C;;AACD;AAED;;;AACA,gBAAI/C,CAAC,CAACuE,YAAF,IAAkBjG,SAAtB,EAAiC;AAC/B;;AAEA;AACAgG,cAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmB,CAAnB,EAAsBA,CAAC,CAACuE,YAAF,GAAiBjG,SAAvC,CAAT;AAEA0B,cAAAA,CAAC,CAAC+C,SAAF,IAAe/C,CAAC,CAACuE,YAAjB;AACAvE,cAAAA,CAAC,CAACc,QAAF,IAAcd,CAAC,CAACuE,YAAhB;AACAvE,cAAAA,CAAC,CAACuE,YAAF,GAAiB,CAAjB;AACD,aATD,MASO;AACL;AACA;;AACA;AACAD,cAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmB,CAAnB,EAAsBA,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAX,CAAtB,CAAT;AAEAd,cAAAA,CAAC,CAAC+C,SAAF;AACA/C,cAAAA,CAAC,CAACc,QAAF;AACD;;AACD,gBAAIwD,MAAJ,EAAY;AACV;AACA5D,cAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,kBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,uBAAOlB,YAAP;AACD;AACD;;AACD;AACF;;AACDe,UAAAA,CAAC,CAAC2D,MAAF,GAAW,CAAX;;AACA,cAAIK,KAAK,KAAKnH,QAAd,EAAwB;AACtB;AACA6D,YAAAA,gBAAgB,CAACV,CAAD,EAAI,IAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOhB,iBAAP;AACD;AACD;;;AACA,mBAAOC,cAAP;AACD;;AACD,cAAIY,CAAC,CAAC0E,QAAN,EAAgB;AACd;AACAhE,YAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOlB,YAAP;AACD;AACD;;AACD;;AACD,iBAAOC,aAAP;AACD;AAED;AACD;AACA;AACA;;;AACC,iBAAS+F,YAAT,CAAsBjF,CAAtB,EAAyBgE,KAAzB,EAAgC;AAC9B,cAAIM,MAAJ;AAAwB;;AAExB,mBAAS;AACP;AACA,gBAAItE,CAAC,CAAC+C,SAAF,KAAgB,CAApB,EAAuB;AACrBE,cAAAA,WAAW,CAACjD,CAAD,CAAX;;AACA,kBAAIA,CAAC,CAAC+C,SAAF,KAAgB,CAApB,EAAuB;AACrB,oBAAIiB,KAAK,KAAKtH,UAAd,EAA0B;AACxB,yBAAOuC,YAAP;AACD;;AACD;AAAY;AACb;AACF;AAED;;;AACAe,YAAAA,CAAC,CAACuE,YAAF,GAAiB,CAAjB,CAbO,CAcP;;AACA;;AACAD,YAAAA,MAAM,GAAGhI,KAAK,CAACkI,SAAN,CAAgBxE,CAAhB,EAAmB,CAAnB,EAAsBA,CAAC,CAACuC,MAAF,CAASvC,CAAC,CAACc,QAAX,CAAtB,CAAT;AACAd,YAAAA,CAAC,CAAC+C,SAAF;AACA/C,YAAAA,CAAC,CAACc,QAAF;;AACA,gBAAIwD,MAAJ,EAAY;AACV;AACA5D,cAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,kBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,uBAAOlB,YAAP;AACD;AACD;;AACD;AACF;;AACDe,UAAAA,CAAC,CAAC2D,MAAF,GAAW,CAAX;;AACA,cAAIK,KAAK,KAAKnH,QAAd,EAAwB;AACtB;AACA6D,YAAAA,gBAAgB,CAACV,CAAD,EAAI,IAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOhB,iBAAP;AACD;AACD;;;AACA,mBAAOC,cAAP;AACD;;AACD,cAAIY,CAAC,CAAC0E,QAAN,EAAgB;AACd;AACAhE,YAAAA,gBAAgB,CAACV,CAAD,EAAI,KAAJ,CAAhB;;AACA,gBAAIA,CAAC,CAACT,IAAF,CAAOY,SAAP,KAAqB,CAAzB,EAA4B;AAC1B,qBAAOlB,YAAP;AACD;AACD;;AACD;;AACD,iBAAOC,aAAP;AACD;AAED;AACD;AACA;AACA;AACA;;;AACC,iBAASgG,MAAT,CAAgBC,WAAhB,EAA6BC,QAA7B,EAAuCC,WAAvC,EAAoDC,SAApD,EAA+DC,IAA/D,EAAqE;AACnE,eAAKJ,WAAL,GAAmBA,WAAnB;AACA,eAAKC,QAAL,GAAgBA,QAAhB;AACA,eAAKC,WAAL,GAAmBA,WAAnB;AACA,eAAKC,SAAL,GAAiBA,SAAjB;AACA,eAAKC,IAAL,GAAYA,IAAZ;AACD;;AAED,YAAIC,mBAAJ;AAEAA,QAAAA,mBAAmB,GAAG;AACpB;AACA,YAAIN,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuBnB,cAAvB,CAFoB;AAE6B;AACjD,YAAImB,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuBd,YAAvB,CAHoB;AAG6B;AACjD,YAAIc,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,EAAjB,EAAqB,CAArB,EAAwBd,YAAxB,CAJoB;AAI6B;AACjD,YAAIc,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,EAAjB,EAAqB,EAArB,EAAyBd,YAAzB,CALoB;AAK6B;AAEjD,YAAIc,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,EAAjB,EAAqB,EAArB,EAAyBP,YAAzB,CAPoB;AAO6B;AACjD,YAAIO,MAAJ,CAAW,CAAX,EAAc,EAAd,EAAkB,EAAlB,EAAsB,EAAtB,EAA0BP,YAA1B,CARoB;AAQ6B;AACjD,YAAIO,MAAJ,CAAW,CAAX,EAAc,EAAd,EAAkB,GAAlB,EAAuB,GAAvB,EAA4BP,YAA5B,CAToB;AAS6B;AACjD,YAAIO,MAAJ,CAAW,CAAX,EAAc,EAAd,EAAkB,GAAlB,EAAuB,GAAvB,EAA4BP,YAA5B,CAVoB;AAU6B;AACjD,YAAIO,MAAJ,CAAW,EAAX,EAAe,GAAf,EAAoB,GAApB,EAAyB,IAAzB,EAA+BP,YAA/B,CAXoB;AAW6B;AACjD,YAAIO,MAAJ,CAAW,EAAX,EAAe,GAAf,EAAoB,GAApB,EAAyB,IAAzB,EAA+BP,YAA/B;AAAiD;AAZ7B,SAAtB;AAgBA;AACD;AACA;;AACC,iBAASc,OAAT,CAAiBzF,CAAjB,EAAoB;AAClBA,UAAAA,CAAC,CAACwD,WAAF,GAAgB,IAAIxD,CAAC,CAACqC,MAAtB;AAEA;;AACA1C,UAAAA,IAAI,CAACK,CAAC,CAAC0D,IAAH,CAAJ,CAJkB,CAIJ;;AAEd;AACH;;AACG1D,UAAAA,CAAC,CAACyE,cAAF,GAAmBe,mBAAmB,CAACxF,CAAC,CAAC0F,KAAH,CAAnB,CAA6BN,QAAhD;AACApF,UAAAA,CAAC,CAAC8C,UAAF,GAAe0C,mBAAmB,CAACxF,CAAC,CAAC0F,KAAH,CAAnB,CAA6BP,WAA5C;AACAnF,UAAAA,CAAC,CAACmC,UAAF,GAAeqD,mBAAmB,CAACxF,CAAC,CAAC0F,KAAH,CAAnB,CAA6BL,WAA5C;AACArF,UAAAA,CAAC,CAAC8B,gBAAF,GAAqB0D,mBAAmB,CAACxF,CAAC,CAAC0F,KAAH,CAAnB,CAA6BJ,SAAlD;AAEAtF,UAAAA,CAAC,CAACc,QAAF,GAAa,CAAb;AACAd,UAAAA,CAAC,CAACa,WAAF,GAAgB,CAAhB;AACAb,UAAAA,CAAC,CAAC+C,SAAF,GAAc,CAAd;AACA/C,UAAAA,CAAC,CAAC2D,MAAF,GAAW,CAAX;AACA3D,UAAAA,CAAC,CAACuE,YAAF,GAAiBvE,CAAC,CAACkC,WAAF,GAAgB5D,SAAS,GAAG,CAA7C;AACA0B,UAAAA,CAAC,CAAC+E,eAAF,GAAoB,CAApB;AACA/E,UAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAV;AACD;;AAGD,iBAAS+B,YAAT,GAAwB;AACtB,eAAKpG,IAAL,GAAY,IAAZ;AAA6B;;AAC7B,eAAKqG,MAAL,GAAc,CAAd;AAA4B;;AAC5B,eAAKtF,WAAL,GAAmB,IAAnB;AAA8B;;AAC9B,eAAK4D,gBAAL,GAAwB,CAAxB;AAA4B;;AAC5B,eAAK3D,WAAL,GAAmB,CAAnB;AAA4B;;AAC5B,eAAKL,OAAL,GAAe,CAAf;AAA4B;;AAC5B,eAAKsB,IAAL,GAAY,CAAZ;AAA4B;;AAC5B,eAAKqE,MAAL,GAAc,IAAd;AAA4B;;AAC5B,eAAKC,OAAL,GAAe,CAAf;AAA4B;;AAC5B,eAAKC,MAAL,GAAcpI,UAAd;AAA0B;;AAC1B,eAAKqI,UAAL,GAAkB,CAAC,CAAnB;AAAwB;;AAExB,eAAK3D,MAAL,GAAc,CAAd;AAAkB;;AAClB,eAAK4D,MAAL,GAAc,CAAd;AAAkB;;AAClB,eAAKxD,MAAL,GAAc,CAAd;AAAkB;;AAElB,eAAKF,MAAL,GAAc,IAAd;AACA;AACH;AACA;AACA;AACA;AACA;;AAEG,eAAKiB,WAAL,GAAmB,CAAnB;AACA;AACH;AACA;;AAEG,eAAKd,IAAL,GAAY,IAAZ;AACA;AACH;AACA;AACA;;AAEG,eAAKgB,IAAL,GAAY,IAAZ;AAAoB;;AAEpB,eAAKE,KAAL,GAAa,CAAb;AAAsB;;AACtB,eAAKH,SAAL,GAAiB,CAAjB;AAAsB;;AACtB,eAAKyC,SAAL,GAAiB,CAAjB;AAAsB;;AACtB,eAAKpC,SAAL,GAAiB,CAAjB;AAAsB;;AAEtB,eAAKD,UAAL,GAAkB,CAAlB;AACA;AACH;AACA;AACA;AACA;;AAEG,eAAKhD,WAAL,GAAmB,CAAnB;AACA;AACH;AACA;;AAEG,eAAK0D,YAAL,GAAoB,CAApB;AAA4B;;AAC5B,eAAKM,UAAL,GAAkB,CAAlB;AAA4B;;AAC5B,eAAKE,eAAL,GAAuB,CAAvB;AAA4B;;AAC5B,eAAKjE,QAAL,GAAgB,CAAhB;AAA4B;;AAC5B,eAAKkC,WAAL,GAAmB,CAAnB;AAA4B;;AAC5B,eAAKD,SAAL,GAAiB,CAAjB;AAA4B;;AAE5B,eAAKb,WAAL,GAAmB,CAAnB;AACA;AACH;AACA;;AAEG,eAAKJ,gBAAL,GAAwB,CAAxB;AACA;AACH;AACA;AACA;;AAEG,eAAK2C,cAAL,GAAsB,CAAtB;AACA;AACH;AACA;AACA;AACG;AACA;;AACA;AACH;AACA;AACA;;AAEG,eAAKiB,KAAL,GAAa,CAAb;AAAoB;;AACpB,eAAKZ,QAAL,GAAgB,CAAhB;AAAoB;;AAEpB,eAAKhC,UAAL,GAAkB,CAAlB;AACA;;AAEA,eAAKX,UAAL,GAAkB,CAAlB;AAAqB;;AAET;;AAEZ;AAEA;AACA;AACA;AAEA;AACA;;AACA,eAAKgE,SAAL,GAAkB,IAAI9J,KAAK,CAAC+J,KAAV,CAAgBhI,SAAS,GAAG,CAA5B,CAAlB;AACA,eAAKiI,SAAL,GAAkB,IAAIhK,KAAK,CAAC+J,KAAV,CAAgB,CAAC,IAAIlI,OAAJ,GAAc,CAAf,IAAoB,CAApC,CAAlB;AACA,eAAKoI,OAAL,GAAkB,IAAIjK,KAAK,CAAC+J,KAAV,CAAgB,CAAC,IAAIjI,QAAJ,GAAe,CAAhB,IAAqB,CAArC,CAAlB;AACAwB,UAAAA,IAAI,CAAC,KAAKwG,SAAN,CAAJ;AACAxG,UAAAA,IAAI,CAAC,KAAK0G,SAAN,CAAJ;AACA1G,UAAAA,IAAI,CAAC,KAAK2G,OAAN,CAAJ;AAEA,eAAKC,MAAL,GAAgB,IAAhB;AAA8B;;AAC9B,eAAKC,MAAL,GAAgB,IAAhB;AAA8B;;AAC9B,eAAKC,OAAL,GAAgB,IAAhB;AAA8B;AAE9B;;AACA,eAAKC,QAAL,GAAgB,IAAIrK,KAAK,CAAC+J,KAAV,CAAgB/H,QAAQ,GAAG,CAA3B,CAAhB;AACA;AAEA;;AACA,eAAKsI,IAAL,GAAY,IAAItK,KAAK,CAAC+J,KAAV,CAAgB,IAAInI,OAAJ,GAAc,CAA9B,CAAZ;AAA+C;;AAC/C0B,UAAAA,IAAI,CAAC,KAAKgH,IAAN,CAAJ;AAEA,eAAKC,QAAL,GAAgB,CAAhB;AAAiC;;AACjC,eAAKC,QAAL,GAAgB,CAAhB;AAAiC;;AACjC;AACH;AACA;;AAEG,eAAKC,KAAL,GAAa,IAAIzK,KAAK,CAAC+J,KAAV,CAAgB,IAAInI,OAAJ,GAAc,CAA9B,CAAb,CAhIsB,CAgIyB;;AAC/C0B,UAAAA,IAAI,CAAC,KAAKmH,KAAN,CAAJ;AACA;AACH;;AAEG,eAAKC,KAAL,GAAa,CAAb;AAAyB;;AAEzB,eAAKC,WAAL,GAAmB,CAAnB;AACA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEG,eAAKtC,QAAL,GAAgB,CAAhB;AAAwB;;AAExB,eAAKuC,KAAL,GAAa,CAAb;AACA;AACH;AACA;AACA;;AAEG,eAAKC,OAAL,GAAe,CAAf;AAAwB;;AACxB,eAAKC,UAAL,GAAkB,CAAlB;AAAwB;;AACxB,eAAKC,OAAL,GAAe,CAAf;AAAwB;;AACxB,eAAKzD,MAAL,GAAc,CAAd;AAAwB;;AAGxB,eAAK0D,MAAL,GAAc,CAAd;AACA;AACH;AACA;;AACG,eAAKC,QAAL,GAAgB,CAAhB;AACA;AACH;AACA;AAEG;AACA;AACA;;AACA;AACH;AACA;AACA;AACA;AACE;;AAGD,iBAASC,gBAAT,CAA0BhI,IAA1B,EAAgC;AAC9B,cAAIS,CAAJ;;AAEA,cAAI,CAACT,IAAD,IAAS,CAACA,IAAI,CAACU,KAAnB,EAA0B;AACxB,mBAAOX,GAAG,CAACC,IAAD,EAAOtC,cAAP,CAAV;AACD;;AAEDsC,UAAAA,IAAI,CAACmC,QAAL,GAAgBnC,IAAI,CAACkB,SAAL,GAAiB,CAAjC;AACAlB,UAAAA,IAAI,CAACiI,SAAL,GAAiB9J,SAAjB;AAEAsC,UAAAA,CAAC,GAAGT,IAAI,CAACU,KAAT;AACAD,UAAAA,CAAC,CAACE,OAAF,GAAY,CAAZ;AACAF,UAAAA,CAAC,CAACO,WAAF,GAAgB,CAAhB;;AAEA,cAAIP,CAAC,CAACwB,IAAF,GAAS,CAAb,EAAgB;AACdxB,YAAAA,CAAC,CAACwB,IAAF,GAAS,CAACxB,CAAC,CAACwB,IAAZ;AACA;AACD;;AACDxB,UAAAA,CAAC,CAAC4F,MAAF,GAAY5F,CAAC,CAACwB,IAAF,GAAS9C,UAAT,GAAsBK,UAAlC;AACAQ,UAAAA,IAAI,CAACkC,KAAL,GAAczB,CAAC,CAACwB,IAAF,KAAW,CAAZ,GACX,CADW,CACR;AADQ,YAGX,CAHF,CAnB8B,CAsBzB;;AACLxB,UAAAA,CAAC,CAACgG,UAAF,GAAetJ,UAAf;;AACAJ,UAAAA,KAAK,CAACmL,QAAN,CAAezH,CAAf;;AACA,iBAAOjD,IAAP;AACD;;AAGD,iBAAS2K,YAAT,CAAsBnI,IAAtB,EAA4B;AAC1B,cAAIoI,GAAG,GAAGJ,gBAAgB,CAAChI,IAAD,CAA1B;;AACA,cAAIoI,GAAG,KAAK5K,IAAZ,EAAkB;AAChB0I,YAAAA,OAAO,CAAClG,IAAI,CAACU,KAAN,CAAP;AACD;;AACD,iBAAO0H,GAAP;AACD;;AAGD,iBAASC,gBAAT,CAA0BrI,IAA1B,EAAgCmE,IAAhC,EAAsC;AACpC,cAAI,CAACnE,IAAD,IAAS,CAACA,IAAI,CAACU,KAAnB,EAA0B;AAAE,mBAAOhD,cAAP;AAAwB;;AACpD,cAAIsC,IAAI,CAACU,KAAL,CAAWuB,IAAX,KAAoB,CAAxB,EAA2B;AAAE,mBAAOvE,cAAP;AAAwB;;AACrDsC,UAAAA,IAAI,CAACU,KAAL,CAAW4F,MAAX,GAAoBnC,IAApB;AACA,iBAAO3G,IAAP;AACD;;AAGD,iBAAS8K,YAAT,CAAsBtI,IAAtB,EAA4BmG,KAA5B,EAAmCK,MAAnC,EAA2C+B,UAA3C,EAAuDC,QAAvD,EAAiEjD,QAAjE,EAA2E;AACzE,cAAI,CAACvF,IAAL,EAAW;AAAE;AACX,mBAAOtC,cAAP;AACD;;AACD,cAAIuE,IAAI,GAAG,CAAX;;AAEA,cAAIkE,KAAK,KAAKtI,qBAAd,EAAqC;AACnCsI,YAAAA,KAAK,GAAG,CAAR;AACD;;AAED,cAAIoC,UAAU,GAAG,CAAjB,EAAoB;AAAE;AACpBtG,YAAAA,IAAI,GAAG,CAAP;AACAsG,YAAAA,UAAU,GAAG,CAACA,UAAd;AACD,WAHD,MAKK,IAAIA,UAAU,GAAG,EAAjB,EAAqB;AACxBtG,YAAAA,IAAI,GAAG,CAAP;AAAoB;;AACpBsG,YAAAA,UAAU,IAAI,EAAd;AACD;;AAGD,cAAIC,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,GAAGnK,aAA3B,IAA4CmI,MAAM,KAAKpI,UAAvD,IACFmK,UAAU,GAAG,CADX,IACgBA,UAAU,GAAG,EAD7B,IACmCpC,KAAK,GAAG,CAD3C,IACgDA,KAAK,GAAG,CADxD,IAEFZ,QAAQ,GAAG,CAFT,IAEcA,QAAQ,GAAGtH,OAF7B,EAEsC;AACpC,mBAAO8B,GAAG,CAACC,IAAD,EAAOtC,cAAP,CAAV;AACD;;AAGD,cAAI6K,UAAU,KAAK,CAAnB,EAAsB;AACpBA,YAAAA,UAAU,GAAG,CAAb;AACD;AACD;;;AAEA,cAAI9H,CAAC,GAAG,IAAI2F,YAAJ,EAAR;AAEApG,UAAAA,IAAI,CAACU,KAAL,GAAaD,CAAb;AACAA,UAAAA,CAAC,CAACT,IAAF,GAASA,IAAT;AAEAS,UAAAA,CAAC,CAACwB,IAAF,GAASA,IAAT;AACAxB,UAAAA,CAAC,CAAC6F,MAAF,GAAW,IAAX;AACA7F,UAAAA,CAAC,CAACiG,MAAF,GAAW6B,UAAX;AACA9H,UAAAA,CAAC,CAACqC,MAAF,GAAW,KAAKrC,CAAC,CAACiG,MAAlB;AACAjG,UAAAA,CAAC,CAACyC,MAAF,GAAWzC,CAAC,CAACqC,MAAF,GAAW,CAAtB;AAEArC,UAAAA,CAAC,CAACkG,SAAF,GAAc6B,QAAQ,GAAG,CAAzB;AACA/H,UAAAA,CAAC,CAACyD,SAAF,GAAc,KAAKzD,CAAC,CAACkG,SAArB;AACAlG,UAAAA,CAAC,CAAC8D,SAAF,GAAc9D,CAAC,CAACyD,SAAF,GAAc,CAA5B;AACAzD,UAAAA,CAAC,CAAC6D,UAAF,GAAe,CAAC,EAAE,CAAC7D,CAAC,CAACkG,SAAF,GAAc5H,SAAd,GAA0B,CAA3B,IAAgCA,SAAlC,CAAhB;AAEA0B,UAAAA,CAAC,CAACuC,MAAF,GAAW,IAAIlG,KAAK,CAAC2L,IAAV,CAAehI,CAAC,CAACqC,MAAF,GAAW,CAA1B,CAAX;AACArC,UAAAA,CAAC,CAAC0D,IAAF,GAAS,IAAIrH,KAAK,CAAC+J,KAAV,CAAgBpG,CAAC,CAACyD,SAAlB,CAAT;AACAzD,UAAAA,CAAC,CAAC0C,IAAF,GAAS,IAAIrG,KAAK,CAAC+J,KAAV,CAAgBpG,CAAC,CAACqC,MAAlB,CAAT,CAnDyE,CAqDzE;AACA;;AAEArC,UAAAA,CAAC,CAACgH,WAAF,GAAgB,KAAMe,QAAQ,GAAG,CAAjC;AAAqC;;AAErC/H,UAAAA,CAAC,CAACkE,gBAAF,GAAqBlE,CAAC,CAACgH,WAAF,GAAgB,CAArC,CA1DyE,CA4DzE;AACA;;AACAhH,UAAAA,CAAC,CAACM,WAAF,GAAgB,IAAIjE,KAAK,CAAC2L,IAAV,CAAehI,CAAC,CAACkE,gBAAjB,CAAhB,CA9DyE,CAgEzE;AACA;;AACAlE,UAAAA,CAAC,CAACiH,KAAF,GAAU,IAAIjH,CAAC,CAACgH,WAAhB,CAlEyE,CAoEzE;;AACAhH,UAAAA,CAAC,CAAC+G,KAAF,GAAU,CAAC,IAAI,CAAL,IAAU/G,CAAC,CAACgH,WAAtB;AAEAhH,UAAAA,CAAC,CAAC0F,KAAF,GAAUA,KAAV;AACA1F,UAAAA,CAAC,CAAC8E,QAAF,GAAaA,QAAb;AACA9E,UAAAA,CAAC,CAAC+F,MAAF,GAAWA,MAAX;AAEA,iBAAO2B,YAAY,CAACnI,IAAD,CAAnB;AACD;;AAED,iBAAS0I,WAAT,CAAqB1I,IAArB,EAA2BmG,KAA3B,EAAkC;AAChC,iBAAOmC,YAAY,CAACtI,IAAD,EAAOmG,KAAP,EAAc/H,UAAd,EAA0BE,SAA1B,EAAqCC,aAArC,EAAoDL,kBAApD,CAAnB;AACD;;AAGD,iBAASyK,OAAT,CAAiB3I,IAAjB,EAAuByE,KAAvB,EAA8B;AAC5B,cAAImE,SAAJ,EAAenI,CAAf;AACA,cAAIoI,GAAJ,EAASC,GAAT,CAF4B,CAEd;;AAEd,cAAI,CAAC9I,IAAD,IAAS,CAACA,IAAI,CAACU,KAAf,IACF+D,KAAK,GAAGlH,OADN,IACiBkH,KAAK,GAAG,CAD7B,EACgC;AAC9B,mBAAOzE,IAAI,GAAGD,GAAG,CAACC,IAAD,EAAOtC,cAAP,CAAN,GAA+BA,cAA1C;AACD;;AAED+C,UAAAA,CAAC,GAAGT,IAAI,CAACU,KAAT;;AAEA,cAAI,CAACV,IAAI,CAACc,MAAN,IACC,CAACd,IAAI,CAAC+B,KAAN,IAAe/B,IAAI,CAAC8B,QAAL,KAAkB,CADlC,IAECrB,CAAC,CAAC4F,MAAF,KAAa5G,YAAb,IAA6BgF,KAAK,KAAKnH,QAF5C,EAEuD;AACrD,mBAAOyC,GAAG,CAACC,IAAD,EAAQA,IAAI,CAACY,SAAL,KAAmB,CAApB,GAAyBhD,WAAzB,GAAuCF,cAA9C,CAAV;AACD;;AAED+C,UAAAA,CAAC,CAACT,IAAF,GAASA,IAAT;AAAe;;AACf4I,UAAAA,SAAS,GAAGnI,CAAC,CAACgG,UAAd;AACAhG,UAAAA,CAAC,CAACgG,UAAF,GAAehC,KAAf;AAEA;;AACA,cAAIhE,CAAC,CAAC4F,MAAF,KAAalH,UAAjB,EAA6B;AAE3B,gBAAIsB,CAAC,CAACwB,IAAF,KAAW,CAAf,EAAkB;AAAE;AAClBjC,cAAAA,IAAI,CAACkC,KAAL,GAAa,CAAb,CADgB,CACC;;AACjBV,cAAAA,QAAQ,CAACf,CAAD,EAAI,EAAJ,CAAR;AACAe,cAAAA,QAAQ,CAACf,CAAD,EAAI,GAAJ,CAAR;AACAe,cAAAA,QAAQ,CAACf,CAAD,EAAI,CAAJ,CAAR;;AACA,kBAAI,CAACA,CAAC,CAAC6F,MAAP,EAAe;AAAE;AACf9E,gBAAAA,QAAQ,CAACf,CAAD,EAAI,CAAJ,CAAR;AACAe,gBAAAA,QAAQ,CAACf,CAAD,EAAI,CAAJ,CAAR;AACAe,gBAAAA,QAAQ,CAACf,CAAD,EAAI,CAAJ,CAAR;AACAe,gBAAAA,QAAQ,CAACf,CAAD,EAAI,CAAJ,CAAR;AACAe,gBAAAA,QAAQ,CAACf,CAAD,EAAI,CAAJ,CAAR;AACAe,gBAAAA,QAAQ,CAACf,CAAD,EAAIA,CAAC,CAAC0F,KAAF,KAAY,CAAZ,GAAgB,CAAhB,GACC1F,CAAC,CAAC8E,QAAF,IAAcxH,cAAd,IAAgC0C,CAAC,CAAC0F,KAAF,GAAU,CAA1C,GACA,CADA,GACI,CAFT,CAAR;AAGA3E,gBAAAA,QAAQ,CAACf,CAAD,EAAIX,OAAJ,CAAR;AACAW,gBAAAA,CAAC,CAAC4F,MAAF,GAAW7G,UAAX;AACD,eAXD,MAYK;AACHgC,gBAAAA,QAAQ,CAACf,CAAD,EAAI,CAACA,CAAC,CAAC6F,MAAF,CAASyC,IAAT,GAAgB,CAAhB,GAAoB,CAArB,KACCtI,CAAC,CAAC6F,MAAF,CAAS0C,IAAT,GAAgB,CAAhB,GAAoB,CADrB,KAEC,CAACvI,CAAC,CAAC6F,MAAF,CAAS2C,KAAV,GAAkB,CAAlB,GAAsB,CAFvB,KAGC,CAACxI,CAAC,CAAC6F,MAAF,CAAS4C,IAAV,GAAiB,CAAjB,GAAqB,CAHtB,KAIC,CAACzI,CAAC,CAAC6F,MAAF,CAAS6C,OAAV,GAAoB,CAApB,GAAwB,EAJzB,CAAJ,CAAR;AAMA3H,gBAAAA,QAAQ,CAACf,CAAD,EAAIA,CAAC,CAAC6F,MAAF,CAAS8C,IAAT,GAAgB,IAApB,CAAR;AACA5H,gBAAAA,QAAQ,CAACf,CAAD,EAAKA,CAAC,CAAC6F,MAAF,CAAS8C,IAAT,IAAiB,CAAlB,GAAuB,IAA3B,CAAR;AACA5H,gBAAAA,QAAQ,CAACf,CAAD,EAAKA,CAAC,CAAC6F,MAAF,CAAS8C,IAAT,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACA5H,gBAAAA,QAAQ,CAACf,CAAD,EAAKA,CAAC,CAAC6F,MAAF,CAAS8C,IAAT,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACA5H,gBAAAA,QAAQ,CAACf,CAAD,EAAIA,CAAC,CAAC0F,KAAF,KAAY,CAAZ,GAAgB,CAAhB,GACC1F,CAAC,CAAC8E,QAAF,IAAcxH,cAAd,IAAgC0C,CAAC,CAAC0F,KAAF,GAAU,CAA1C,GACA,CADA,GACI,CAFT,CAAR;AAGA3E,gBAAAA,QAAQ,CAACf,CAAD,EAAIA,CAAC,CAAC6F,MAAF,CAAS+C,EAAT,GAAc,IAAlB,CAAR;;AACA,oBAAI5I,CAAC,CAAC6F,MAAF,CAAS2C,KAAT,IAAkBxI,CAAC,CAAC6F,MAAF,CAAS2C,KAAT,CAAe1I,MAArC,EAA6C;AAC3CiB,kBAAAA,QAAQ,CAACf,CAAD,EAAIA,CAAC,CAAC6F,MAAF,CAAS2C,KAAT,CAAe1I,MAAf,GAAwB,IAA5B,CAAR;AACAiB,kBAAAA,QAAQ,CAACf,CAAD,EAAKA,CAAC,CAAC6F,MAAF,CAAS2C,KAAT,CAAe1I,MAAf,IAAyB,CAA1B,GAA+B,IAAnC,CAAR;AACD;;AACD,oBAAIE,CAAC,CAAC6F,MAAF,CAAS0C,IAAb,EAAmB;AACjBhJ,kBAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAazB,CAAC,CAACM,WAAf,EAA4BN,CAAC,CAACE,OAA9B,EAAuC,CAAvC,CAAlB;AACD;;AACDF,gBAAAA,CAAC,CAAC8F,OAAF,GAAY,CAAZ;AACA9F,gBAAAA,CAAC,CAAC4F,MAAF,GAAWjH,WAAX;AACD;AACF,aA1CD,MA2CK;AACL;AACE,oBAAIkK,MAAM,GAAIlL,UAAU,IAAKqC,CAAC,CAACiG,MAAF,GAAW,CAAZ,IAAkB,CAAtB,CAAX,IAAwC,CAArD;AACA,oBAAI6C,WAAW,GAAG,CAAC,CAAnB;;AAEA,oBAAI9I,CAAC,CAAC8E,QAAF,IAAcxH,cAAd,IAAgC0C,CAAC,CAAC0F,KAAF,GAAU,CAA9C,EAAiD;AAC/CoD,kBAAAA,WAAW,GAAG,CAAd;AACD,iBAFD,MAEO,IAAI9I,CAAC,CAAC0F,KAAF,GAAU,CAAd,EAAiB;AACtBoD,kBAAAA,WAAW,GAAG,CAAd;AACD,iBAFM,MAEA,IAAI9I,CAAC,CAAC0F,KAAF,KAAY,CAAhB,EAAmB;AACxBoD,kBAAAA,WAAW,GAAG,CAAd;AACD,iBAFM,MAEA;AACLA,kBAAAA,WAAW,GAAG,CAAd;AACD;;AACDD,gBAAAA,MAAM,IAAKC,WAAW,IAAI,CAA1B;;AACA,oBAAI9I,CAAC,CAACc,QAAF,KAAe,CAAnB,EAAsB;AAAE+H,kBAAAA,MAAM,IAAIpK,WAAV;AAAwB;;AAChDoK,gBAAAA,MAAM,IAAI,KAAMA,MAAM,GAAG,EAAzB;AAEA7I,gBAAAA,CAAC,CAAC4F,MAAF,GAAW7G,UAAX;AACAkC,gBAAAA,WAAW,CAACjB,CAAD,EAAI6I,MAAJ,CAAX;AAEA;;AACA,oBAAI7I,CAAC,CAACc,QAAF,KAAe,CAAnB,EAAsB;AACpBG,kBAAAA,WAAW,CAACjB,CAAD,EAAIT,IAAI,CAACkC,KAAL,KAAe,EAAnB,CAAX;AACAR,kBAAAA,WAAW,CAACjB,CAAD,EAAIT,IAAI,CAACkC,KAAL,GAAa,MAAjB,CAAX;AACD;;AACDlC,gBAAAA,IAAI,CAACkC,KAAL,GAAa,CAAb,CAzBF,CAyBkB;AACjB;AACF,WA/F2B,CAiG9B;;;AACE,cAAIzB,CAAC,CAAC4F,MAAF,KAAajH,WAAjB,EAA8B;AAC5B,gBAAIqB,CAAC,CAAC6F,MAAF,CAAS2C;AAAK;AAAlB,cAAkC;AAChCJ,cAAAA,GAAG,GAAGpI,CAAC,CAACE,OAAR;AAAkB;;AAElB,qBAAOF,CAAC,CAAC8F,OAAF,IAAa9F,CAAC,CAAC6F,MAAF,CAAS2C,KAAT,CAAe1I,MAAf,GAAwB,MAArC,CAAP,EAAqD;AACnD,oBAAIE,CAAC,CAACE,OAAF,KAAcF,CAAC,CAACkE,gBAApB,EAAsC;AACpC,sBAAIlE,CAAC,CAAC6F,MAAF,CAAS0C,IAAT,IAAiBvI,CAAC,CAACE,OAAF,GAAYkI,GAAjC,EAAsC;AACpC7I,oBAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAazB,CAAC,CAACM,WAAf,EAA4BN,CAAC,CAACE,OAAF,GAAYkI,GAAxC,EAA6CA,GAA7C,CAAlB;AACD;;AACDrI,kBAAAA,aAAa,CAACR,IAAD,CAAb;AACA6I,kBAAAA,GAAG,GAAGpI,CAAC,CAACE,OAAR;;AACA,sBAAIF,CAAC,CAACE,OAAF,KAAcF,CAAC,CAACkE,gBAApB,EAAsC;AACpC;AACD;AACF;;AACDnD,gBAAAA,QAAQ,CAACf,CAAD,EAAIA,CAAC,CAAC6F,MAAF,CAAS2C,KAAT,CAAexI,CAAC,CAAC8F,OAAjB,IAA4B,IAAhC,CAAR;AACA9F,gBAAAA,CAAC,CAAC8F,OAAF;AACD;;AACD,kBAAI9F,CAAC,CAAC6F,MAAF,CAAS0C,IAAT,IAAiBvI,CAAC,CAACE,OAAF,GAAYkI,GAAjC,EAAsC;AACpC7I,gBAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAazB,CAAC,CAACM,WAAf,EAA4BN,CAAC,CAACE,OAAF,GAAYkI,GAAxC,EAA6CA,GAA7C,CAAlB;AACD;;AACD,kBAAIpI,CAAC,CAAC8F,OAAF,KAAc9F,CAAC,CAAC6F,MAAF,CAAS2C,KAAT,CAAe1I,MAAjC,EAAyC;AACvCE,gBAAAA,CAAC,CAAC8F,OAAF,GAAY,CAAZ;AACA9F,gBAAAA,CAAC,CAAC4F,MAAF,GAAWhH,UAAX;AACD;AACF,aAxBD,MAyBK;AACHoB,cAAAA,CAAC,CAAC4F,MAAF,GAAWhH,UAAX;AACD;AACF;;AACD,cAAIoB,CAAC,CAAC4F,MAAF,KAAahH,UAAjB,EAA6B;AAC3B,gBAAIoB,CAAC,CAAC6F,MAAF,CAAS4C;AAAI;AAAjB,cAAiC;AAC/BL,cAAAA,GAAG,GAAGpI,CAAC,CAACE,OAAR;AAAkB;AAClB;;AAEA,iBAAG;AACD,oBAAIF,CAAC,CAACE,OAAF,KAAcF,CAAC,CAACkE,gBAApB,EAAsC;AACpC,sBAAIlE,CAAC,CAAC6F,MAAF,CAAS0C,IAAT,IAAiBvI,CAAC,CAACE,OAAF,GAAYkI,GAAjC,EAAsC;AACpC7I,oBAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAazB,CAAC,CAACM,WAAf,EAA4BN,CAAC,CAACE,OAAF,GAAYkI,GAAxC,EAA6CA,GAA7C,CAAlB;AACD;;AACDrI,kBAAAA,aAAa,CAACR,IAAD,CAAb;AACA6I,kBAAAA,GAAG,GAAGpI,CAAC,CAACE,OAAR;;AACA,sBAAIF,CAAC,CAACE,OAAF,KAAcF,CAAC,CAACkE,gBAApB,EAAsC;AACpCmE,oBAAAA,GAAG,GAAG,CAAN;AACA;AACD;AACF,iBAXA,CAYD;;;AACA,oBAAIrI,CAAC,CAAC8F,OAAF,GAAY9F,CAAC,CAAC6F,MAAF,CAAS4C,IAAT,CAAc3I,MAA9B,EAAsC;AACpCuI,kBAAAA,GAAG,GAAGrI,CAAC,CAAC6F,MAAF,CAAS4C,IAAT,CAAcM,UAAd,CAAyB/I,CAAC,CAAC8F,OAAF,EAAzB,IAAwC,IAA9C;AACD,iBAFD,MAEO;AACLuC,kBAAAA,GAAG,GAAG,CAAN;AACD;;AACDtH,gBAAAA,QAAQ,CAACf,CAAD,EAAIqI,GAAJ,CAAR;AACD,eAnBD,QAmBSA,GAAG,KAAK,CAnBjB;;AAqBA,kBAAIrI,CAAC,CAAC6F,MAAF,CAAS0C,IAAT,IAAiBvI,CAAC,CAACE,OAAF,GAAYkI,GAAjC,EAAsC;AACpC7I,gBAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAazB,CAAC,CAACM,WAAf,EAA4BN,CAAC,CAACE,OAAF,GAAYkI,GAAxC,EAA6CA,GAA7C,CAAlB;AACD;;AACD,kBAAIC,GAAG,KAAK,CAAZ,EAAe;AACbrI,gBAAAA,CAAC,CAAC8F,OAAF,GAAY,CAAZ;AACA9F,gBAAAA,CAAC,CAAC4F,MAAF,GAAW/G,aAAX;AACD;AACF,aAhCD,MAiCK;AACHmB,cAAAA,CAAC,CAAC4F,MAAF,GAAW/G,aAAX;AACD;AACF;;AACD,cAAImB,CAAC,CAAC4F,MAAF,KAAa/G,aAAjB,EAAgC;AAC9B,gBAAImB,CAAC,CAAC6F,MAAF,CAAS6C;AAAO;AAApB,cAAoC;AAClCN,cAAAA,GAAG,GAAGpI,CAAC,CAACE,OAAR;AAAkB;AAClB;;AAEA,iBAAG;AACD,oBAAIF,CAAC,CAACE,OAAF,KAAcF,CAAC,CAACkE,gBAApB,EAAsC;AACpC,sBAAIlE,CAAC,CAAC6F,MAAF,CAAS0C,IAAT,IAAiBvI,CAAC,CAACE,OAAF,GAAYkI,GAAjC,EAAsC;AACpC7I,oBAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAazB,CAAC,CAACM,WAAf,EAA4BN,CAAC,CAACE,OAAF,GAAYkI,GAAxC,EAA6CA,GAA7C,CAAlB;AACD;;AACDrI,kBAAAA,aAAa,CAACR,IAAD,CAAb;AACA6I,kBAAAA,GAAG,GAAGpI,CAAC,CAACE,OAAR;;AACA,sBAAIF,CAAC,CAACE,OAAF,KAAcF,CAAC,CAACkE,gBAApB,EAAsC;AACpCmE,oBAAAA,GAAG,GAAG,CAAN;AACA;AACD;AACF,iBAXA,CAYD;;;AACA,oBAAIrI,CAAC,CAAC8F,OAAF,GAAY9F,CAAC,CAAC6F,MAAF,CAAS6C,OAAT,CAAiB5I,MAAjC,EAAyC;AACvCuI,kBAAAA,GAAG,GAAGrI,CAAC,CAAC6F,MAAF,CAAS6C,OAAT,CAAiBK,UAAjB,CAA4B/I,CAAC,CAAC8F,OAAF,EAA5B,IAA2C,IAAjD;AACD,iBAFD,MAEO;AACLuC,kBAAAA,GAAG,GAAG,CAAN;AACD;;AACDtH,gBAAAA,QAAQ,CAACf,CAAD,EAAIqI,GAAJ,CAAR;AACD,eAnBD,QAmBSA,GAAG,KAAK,CAnBjB;;AAqBA,kBAAIrI,CAAC,CAAC6F,MAAF,CAAS0C,IAAT,IAAiBvI,CAAC,CAACE,OAAF,GAAYkI,GAAjC,EAAsC;AACpC7I,gBAAAA,IAAI,CAACkC,KAAL,GAAajF,KAAK,CAAC+C,IAAI,CAACkC,KAAN,EAAazB,CAAC,CAACM,WAAf,EAA4BN,CAAC,CAACE,OAAF,GAAYkI,GAAxC,EAA6CA,GAA7C,CAAlB;AACD;;AACD,kBAAIC,GAAG,KAAK,CAAZ,EAAe;AACbrI,gBAAAA,CAAC,CAAC4F,MAAF,GAAW9G,UAAX;AACD;AACF,aA/BD,MAgCK;AACHkB,cAAAA,CAAC,CAAC4F,MAAF,GAAW9G,UAAX;AACD;AACF;;AACD,cAAIkB,CAAC,CAAC4F,MAAF,KAAa9G,UAAjB,EAA6B;AAC3B,gBAAIkB,CAAC,CAAC6F,MAAF,CAAS0C,IAAb,EAAmB;AACjB,kBAAIvI,CAAC,CAACE,OAAF,GAAY,CAAZ,GAAgBF,CAAC,CAACkE,gBAAtB,EAAwC;AACtCnE,gBAAAA,aAAa,CAACR,IAAD,CAAb;AACD;;AACD,kBAAIS,CAAC,CAACE,OAAF,GAAY,CAAZ,IAAiBF,CAAC,CAACkE,gBAAvB,EAAyC;AACvCnD,gBAAAA,QAAQ,CAACf,CAAD,EAAIT,IAAI,CAACkC,KAAL,GAAa,IAAjB,CAAR;AACAV,gBAAAA,QAAQ,CAACf,CAAD,EAAKT,IAAI,CAACkC,KAAL,IAAc,CAAf,GAAoB,IAAxB,CAAR;AACAlC,gBAAAA,IAAI,CAACkC,KAAL,GAAa,CAAb,CAHuC,CAGvB;;AAChBzB,gBAAAA,CAAC,CAAC4F,MAAF,GAAW7G,UAAX;AACD;AACF,aAVD,MAWK;AACHiB,cAAAA,CAAC,CAAC4F,MAAF,GAAW7G,UAAX;AACD;AACF,WA1N2B,CA2N9B;;AAEE;;;AACA,cAAIiB,CAAC,CAACE,OAAF,KAAc,CAAlB,EAAqB;AACnBH,YAAAA,aAAa,CAACR,IAAD,CAAb;;AACA,gBAAIA,IAAI,CAACY,SAAL,KAAmB,CAAvB,EAA0B;AACxB;AACP;AACA;AACA;AACA;AACA;AACOH,cAAAA,CAAC,CAACgG,UAAF,GAAe,CAAC,CAAhB;AACA,qBAAOjJ,IAAP;AACD;AAED;AACL;AACA;AACA;;AACI,WAjBD,MAiBO,IAAIwC,IAAI,CAAC8B,QAAL,KAAkB,CAAlB,IAAuB5B,IAAI,CAACuE,KAAD,CAAJ,IAAevE,IAAI,CAAC0I,SAAD,CAA1C,IACTnE,KAAK,KAAKnH,QADL,EACe;AACpB,mBAAOyC,GAAG,CAACC,IAAD,EAAOpC,WAAP,CAAV;AACD;AAED;;;AACA,cAAI6C,CAAC,CAAC4F,MAAF,KAAa5G,YAAb,IAA6BO,IAAI,CAAC8B,QAAL,KAAkB,CAAnD,EAAsD;AACpD,mBAAO/B,GAAG,CAACC,IAAD,EAAOpC,WAAP,CAAV;AACD;AAED;AACH;;;AACG,cAAIoC,IAAI,CAAC8B,QAAL,KAAkB,CAAlB,IAAuBrB,CAAC,CAAC+C,SAAF,KAAgB,CAAvC,IACDiB,KAAK,KAAKtH,UAAV,IAAwBsD,CAAC,CAAC4F,MAAF,KAAa5G,YADxC,EACuD;AACrD,gBAAIgK,MAAM,GAAIhJ,CAAC,CAAC8E,QAAF,KAAexH,cAAhB,GAAkC2H,YAAY,CAACjF,CAAD,EAAIgE,KAAJ,CAA9C,GACVhE,CAAC,CAAC8E,QAAF,KAAevH,KAAf,GAAuByH,WAAW,CAAChF,CAAD,EAAIgE,KAAJ,CAAlC,GACCwB,mBAAmB,CAACxF,CAAC,CAAC0F,KAAH,CAAnB,CAA6BH,IAA7B,CAAkCvF,CAAlC,EAAqCgE,KAArC,CAFJ;;AAIA,gBAAIgF,MAAM,KAAK7J,iBAAX,IAAgC6J,MAAM,KAAK5J,cAA/C,EAA+D;AAC7DY,cAAAA,CAAC,CAAC4F,MAAF,GAAW5G,YAAX;AACD;;AACD,gBAAIgK,MAAM,KAAK/J,YAAX,IAA2B+J,MAAM,KAAK7J,iBAA1C,EAA6D;AAC3D,kBAAII,IAAI,CAACY,SAAL,KAAmB,CAAvB,EAA0B;AACxBH,gBAAAA,CAAC,CAACgG,UAAF,GAAe,CAAC,CAAhB;AACA;AACD;;AACD,qBAAOjJ,IAAP;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACM;;AACD,gBAAIiM,MAAM,KAAK9J,aAAf,EAA8B;AAC5B,kBAAI8E,KAAK,KAAKrH,eAAd,EAA+B;AAC7BL,gBAAAA,KAAK,CAAC2M,SAAN,CAAgBjJ,CAAhB;AACD,eAFD,MAGK,IAAIgE,KAAK,KAAKlH,OAAd,EAAuB;AAAE;AAE5BR,gBAAAA,KAAK,CAAC4M,gBAAN,CAAuBlJ,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,EAAgC,KAAhC;AACA;AACT;AACA;;;AACS,oBAAIgE,KAAK,KAAKpH,YAAd,EAA4B;AAC1B;;AAAqC;AACrC+C,kBAAAA,IAAI,CAACK,CAAC,CAAC0D,IAAH,CAAJ,CAF0B,CAEZ;;AAEd,sBAAI1D,CAAC,CAAC+C,SAAF,KAAgB,CAApB,EAAuB;AACrB/C,oBAAAA,CAAC,CAACc,QAAF,GAAa,CAAb;AACAd,oBAAAA,CAAC,CAACa,WAAF,GAAgB,CAAhB;AACAb,oBAAAA,CAAC,CAAC2D,MAAF,GAAW,CAAX;AACD;AACF;AACF;;AACD5D,cAAAA,aAAa,CAACR,IAAD,CAAb;;AACA,kBAAIA,IAAI,CAACY,SAAL,KAAmB,CAAvB,EAA0B;AACxBH,gBAAAA,CAAC,CAACgG,UAAF,GAAe,CAAC,CAAhB;AAAmB;;AACnB,uBAAOjJ,IAAP;AACD;AACF;AACF,WA7S2B,CA8S5B;AACA;;;AAEA,cAAIiH,KAAK,KAAKnH,QAAd,EAAwB;AAAE,mBAAOE,IAAP;AAAc;;AACxC,cAAIiD,CAAC,CAACwB,IAAF,IAAU,CAAd,EAAiB;AAAE,mBAAOxE,YAAP;AAAsB;AAEzC;;;AACA,cAAIgD,CAAC,CAACwB,IAAF,KAAW,CAAf,EAAkB;AAChBT,YAAAA,QAAQ,CAACf,CAAD,EAAIT,IAAI,CAACkC,KAAL,GAAa,IAAjB,CAAR;AACAV,YAAAA,QAAQ,CAACf,CAAD,EAAKT,IAAI,CAACkC,KAAL,IAAc,CAAf,GAAoB,IAAxB,CAAR;AACAV,YAAAA,QAAQ,CAACf,CAAD,EAAKT,IAAI,CAACkC,KAAL,IAAc,EAAf,GAAqB,IAAzB,CAAR;AACAV,YAAAA,QAAQ,CAACf,CAAD,EAAKT,IAAI,CAACkC,KAAL,IAAc,EAAf,GAAqB,IAAzB,CAAR;AACAV,YAAAA,QAAQ,CAACf,CAAD,EAAIT,IAAI,CAACmC,QAAL,GAAgB,IAApB,CAAR;AACAX,YAAAA,QAAQ,CAACf,CAAD,EAAKT,IAAI,CAACmC,QAAL,IAAiB,CAAlB,GAAuB,IAA3B,CAAR;AACAX,YAAAA,QAAQ,CAACf,CAAD,EAAKT,IAAI,CAACmC,QAAL,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACAX,YAAAA,QAAQ,CAACf,CAAD,EAAKT,IAAI,CAACmC,QAAL,IAAiB,EAAlB,GAAwB,IAA5B,CAAR;AACD,WATD,MAWA;AACET,YAAAA,WAAW,CAACjB,CAAD,EAAIT,IAAI,CAACkC,KAAL,KAAe,EAAnB,CAAX;AACAR,YAAAA,WAAW,CAACjB,CAAD,EAAIT,IAAI,CAACkC,KAAL,GAAa,MAAjB,CAAX;AACD;;AAED1B,UAAAA,aAAa,CAACR,IAAD,CAAb;AACA;AACH;AACA;;AACG,cAAIS,CAAC,CAACwB,IAAF,GAAS,CAAb,EAAgB;AAAExB,YAAAA,CAAC,CAACwB,IAAF,GAAS,CAACxB,CAAC,CAACwB,IAAZ;AAAmB;AACrC;;;AACA,iBAAOxB,CAAC,CAACE,OAAF,KAAc,CAAd,GAAkBnD,IAAlB,GAAyBC,YAAhC;AACD;;AAED,iBAASmM,UAAT,CAAoB5J,IAApB,EAA0B;AACxB,cAAIqG,MAAJ;;AAEA,cAAI,CAACrG;AAAI;AAAL,aAAsB,CAACA,IAAI,CAACU;AAAK;AAArC,YAAoD;AAClD,mBAAOhD,cAAP;AACD;;AAED2I,UAAAA,MAAM,GAAGrG,IAAI,CAACU,KAAL,CAAW2F,MAApB;;AACA,cAAIA,MAAM,KAAKlH,UAAX,IACFkH,MAAM,KAAKjH,WADT,IAEFiH,MAAM,KAAKhH,UAFT,IAGFgH,MAAM,KAAK/G,aAHT,IAIF+G,MAAM,KAAK9G,UAJT,IAKF8G,MAAM,KAAK7G,UALT,IAMF6G,MAAM,KAAK5G,YANb,EAOE;AACA,mBAAOM,GAAG,CAACC,IAAD,EAAOtC,cAAP,CAAV;AACD;;AAEDsC,UAAAA,IAAI,CAACU,KAAL,GAAa,IAAb;AAEA,iBAAO2F,MAAM,KAAK7G,UAAX,GAAwBO,GAAG,CAACC,IAAD,EAAOrC,YAAP,CAA3B,GAAkDH,IAAzD;AACD;AAGD;AACD;AACA;AACA;;;AACC,iBAASqM,oBAAT,CAA8B7J,IAA9B,EAAoC8J,UAApC,EAAgD;AAC9C,cAAIC,UAAU,GAAGD,UAAU,CAACvJ,MAA5B;AAEA,cAAIE,CAAJ;AACA,cAAIuD,GAAJ,EAASH,CAAT;AACA,cAAI5B,IAAJ;AACA,cAAI+H,KAAJ;AACA,cAAIC,IAAJ;AACA,cAAIlI,KAAJ;AACA,cAAImI,OAAJ;;AAEA,cAAI,CAAClK;AAAI;AAAL,aAAsB,CAACA,IAAI,CAACU;AAAK;AAArC,YAAoD;AAClD,mBAAOhD,cAAP;AACD;;AAED+C,UAAAA,CAAC,GAAGT,IAAI,CAACU,KAAT;AACAuB,UAAAA,IAAI,GAAGxB,CAAC,CAACwB,IAAT;;AAEA,cAAIA,IAAI,KAAK,CAAT,IAAeA,IAAI,KAAK,CAAT,IAAcxB,CAAC,CAAC4F,MAAF,KAAalH,UAA1C,IAAyDsB,CAAC,CAAC+C,SAA/D,EAA0E;AACxE,mBAAO9F,cAAP;AACD;AAED;;;AACA,cAAIuE,IAAI,KAAK,CAAb,EAAgB;AACd;AACAjC,YAAAA,IAAI,CAACkC,KAAL,GAAalF,OAAO,CAACgD,IAAI,CAACkC,KAAN,EAAa4H,UAAb,EAAyBC,UAAzB,EAAqC,CAArC,CAApB;AACD;;AAEDtJ,UAAAA,CAAC,CAACwB,IAAF,GAAS,CAAT;AAAc;;AAEd;;AACA,cAAI8H,UAAU,IAAItJ,CAAC,CAACqC,MAApB,EAA4B;AAC1B,gBAAIb,IAAI,KAAK,CAAb,EAAgB;AAAa;;AAC3B;AACA7B,cAAAA,IAAI,CAACK,CAAC,CAAC0D,IAAH,CAAJ,CAFc,CAEA;;AACd1D,cAAAA,CAAC,CAACc,QAAF,GAAa,CAAb;AACAd,cAAAA,CAAC,CAACa,WAAF,GAAgB,CAAhB;AACAb,cAAAA,CAAC,CAAC2D,MAAF,GAAW,CAAX;AACD;AACD;AACA;;;AACA8F,YAAAA,OAAO,GAAG,IAAIpN,KAAK,CAAC2L,IAAV,CAAehI,CAAC,CAACqC,MAAjB,CAAV;AACAhG,YAAAA,KAAK,CAAC+D,QAAN,CAAeqJ,OAAf,EAAwBJ,UAAxB,EAAoCC,UAAU,GAAGtJ,CAAC,CAACqC,MAAnD,EAA2DrC,CAAC,CAACqC,MAA7D,EAAqE,CAArE;AACAgH,YAAAA,UAAU,GAAGI,OAAb;AACAH,YAAAA,UAAU,GAAGtJ,CAAC,CAACqC,MAAf;AACD;AACD;;;AACAkH,UAAAA,KAAK,GAAGhK,IAAI,CAAC8B,QAAb;AACAmI,UAAAA,IAAI,GAAGjK,IAAI,CAACgC,OAAZ;AACAD,UAAAA,KAAK,GAAG/B,IAAI,CAAC+B,KAAb;AACA/B,UAAAA,IAAI,CAAC8B,QAAL,GAAgBiI,UAAhB;AACA/J,UAAAA,IAAI,CAACgC,OAAL,GAAe,CAAf;AACAhC,UAAAA,IAAI,CAAC+B,KAAL,GAAa+H,UAAb;AACApG,UAAAA,WAAW,CAACjD,CAAD,CAAX;;AACA,iBAAOA,CAAC,CAAC+C,SAAF,IAAezE,SAAtB,EAAiC;AAC/BiF,YAAAA,GAAG,GAAGvD,CAAC,CAACc,QAAR;AACAsC,YAAAA,CAAC,GAAGpD,CAAC,CAAC+C,SAAF,IAAezE,SAAS,GAAG,CAA3B,CAAJ;;AACA,eAAG;AACD;AACA0B,cAAAA,CAAC,CAAC4D,KAAF,GAAU,CAAE5D,CAAC,CAAC4D,KAAF,IAAW5D,CAAC,CAAC6D,UAAd,GAA4B7D,CAAC,CAACuC,MAAF,CAASgB,GAAG,GAAGjF,SAAN,GAAkB,CAA3B,CAA7B,IAA8D0B,CAAC,CAAC8D,SAA1E;AAEA9D,cAAAA,CAAC,CAAC0C,IAAF,CAAOa,GAAG,GAAGvD,CAAC,CAACyC,MAAf,IAAyBzC,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,CAAzB;AAEA5D,cAAAA,CAAC,CAAC0D,IAAF,CAAO1D,CAAC,CAAC4D,KAAT,IAAkBL,GAAlB;AACAA,cAAAA,GAAG;AACJ,aARD,QAQS,EAAEH,CARX;;AASApD,YAAAA,CAAC,CAACc,QAAF,GAAayC,GAAb;AACAvD,YAAAA,CAAC,CAAC+C,SAAF,GAAczE,SAAS,GAAG,CAA1B;AACA2E,YAAAA,WAAW,CAACjD,CAAD,CAAX;AACD;;AACDA,UAAAA,CAAC,CAACc,QAAF,IAAcd,CAAC,CAAC+C,SAAhB;AACA/C,UAAAA,CAAC,CAACa,WAAF,GAAgBb,CAAC,CAACc,QAAlB;AACAd,UAAAA,CAAC,CAAC2D,MAAF,GAAW3D,CAAC,CAAC+C,SAAb;AACA/C,UAAAA,CAAC,CAAC+C,SAAF,GAAc,CAAd;AACA/C,UAAAA,CAAC,CAACuE,YAAF,GAAiBvE,CAAC,CAACkC,WAAF,GAAgB5D,SAAS,GAAG,CAA7C;AACA0B,UAAAA,CAAC,CAAC+E,eAAF,GAAoB,CAApB;AACAxF,UAAAA,IAAI,CAACgC,OAAL,GAAeiI,IAAf;AACAjK,UAAAA,IAAI,CAAC+B,KAAL,GAAaA,KAAb;AACA/B,UAAAA,IAAI,CAAC8B,QAAL,GAAgBkI,KAAhB;AACAvJ,UAAAA,CAAC,CAACwB,IAAF,GAASA,IAAT;AACA,iBAAOzE,IAAP;AACD;;AAGDf,QAAAA,OAAO,CAACiM,WAAR,GAAsBA,WAAtB;AACAjM,QAAAA,OAAO,CAAC6L,YAAR,GAAuBA,YAAvB;AACA7L,QAAAA,OAAO,CAAC0L,YAAR,GAAuBA,YAAvB;AACA1L,QAAAA,OAAO,CAACuL,gBAAR,GAA2BA,gBAA3B;AACAvL,QAAAA,OAAO,CAAC4L,gBAAR,GAA2BA,gBAA3B;AACA5L,QAAAA,OAAO,CAACkM,OAAR,GAAkBA,OAAlB;AACAlM,QAAAA,OAAO,CAACmN,UAAR,GAAqBA,UAArB;AACAnN,QAAAA,OAAO,CAACoN,oBAAR,GAA+BA,oBAA/B;AACApN,QAAAA,OAAO,CAAC0N,WAAR,GAAsB,oCAAtB;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA,2BAAAC,WAAW,GAAGzN,MAAM,CAACF,OAArB;;AACA4N,QAAAA,YAAY,GAAG1N,MAAM,CAACF,OAAP,CAAeiM,WAA9B;AACA4B,QAAAA,aAAa,GAAG3N,MAAM,CAACF,OAAP,CAAe6L,YAA/B;AACAiC,QAAAA,aAAa,GAAG5N,MAAM,CAACF,OAAP,CAAe0L,YAA/B;AACAqC,QAAAA,iBAAiB,GAAG7N,MAAM,CAACF,OAAP,CAAeuL,gBAAnC;AACAyC,QAAAA,iBAAiB,GAAG9N,MAAM,CAACF,OAAP,CAAe4L,gBAAnC;AACAqC,QAAAA,QAAQ,GAAG/N,MAAM,CAACF,OAAP,CAAekM,OAA1B;AACAgC,QAAAA,WAAW,GAAGhO,MAAM,CAACF,OAAP,CAAemN,UAA7B;AACAgB,QAAAA,qBAAqB,GAAGjO,MAAM,CAACF,OAAP,CAAeoN,oBAAvC;AACAgB,QAAAA,YAAY,GAAGlO,MAAM,CAACF,OAAP,CAAe0N,WAA9B;AAEC,OAr2DD,EAq2DG,OAAO;AACR,2BAAmBlO,IADX;AAER,mBAAWE,KAFH;AAGR,qBAAaC,KAHL;AAIR,mBAAWC,KAJH;AAKR,sBAAcC;AALN,OAAP,CAr2DH","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nimport { __cjsMetaURL as _req} from '../utils/common';\nimport { __cjsMetaURL as _req0} from './trees';\nimport { __cjsMetaURL as _req1} from './adler32';\nimport { __cjsMetaURL as _req2} from './crc32';\nimport { __cjsMetaURL as _req3} from './messages';\nlet _cjsExports;\nlet _deflateInit;\nlet _deflateInit2;\nlet _deflateReset;\nlet _deflateResetKeep;\nlet _deflateSetHeader;\nlet _deflate;\nlet _deflateEnd;\nlet _deflateSetDictionary;\nlet _deflateInfo;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n 'use strict';\n\n // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n //\n // This software is provided 'as-is', without any express or implied\n // warranty. In no event will the authors be held liable for any damages\n // arising from the use of this software.\n //\n // Permission is granted to anyone to use this software for any purpose,\n // including commercial applications, and to alter it and redistribute it\n // freely, subject to the following restrictions:\n //\n // 1. The origin of this software must not be misrepresented; you must not\n //   claim that you wrote the original software. If you use this software\n //   in a product, an acknowledgment in the product documentation would be\n //   appreciated but is not required.\n // 2. Altered source versions must be plainly marked as such, and must not be\n //   misrepresented as being the original software.\n // 3. This notice may not be removed or altered from any source distribution.\n\n var utils   = require('../utils/common');\n var trees   = require('./trees');\n var adler32 = require('./adler32');\n var crc32   = require('./crc32');\n var msg     = require('./messages');\n\n /* Public constants ==========================================================*/\n /* ===========================================================================*/\n\n\n /* Allowed flush values; see deflate() and inflate() below for details */\n var Z_NO_FLUSH      = 0;\n var Z_PARTIAL_FLUSH = 1;\n //var Z_SYNC_FLUSH    = 2;\n var Z_FULL_FLUSH    = 3;\n var Z_FINISH        = 4;\n var Z_BLOCK         = 5;\n //var Z_TREES         = 6;\n\n\n /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n var Z_OK            = 0;\n var Z_STREAM_END    = 1;\n //var Z_NEED_DICT     = 2;\n //var Z_ERRNO         = -1;\n var Z_STREAM_ERROR  = -2;\n var Z_DATA_ERROR    = -3;\n //var Z_MEM_ERROR     = -4;\n var Z_BUF_ERROR     = -5;\n //var Z_VERSION_ERROR = -6;\n\n\n /* compression levels */\n //var Z_NO_COMPRESSION      = 0;\n //var Z_BEST_SPEED          = 1;\n //var Z_BEST_COMPRESSION    = 9;\n var Z_DEFAULT_COMPRESSION = -1;\n\n\n var Z_FILTERED            = 1;\n var Z_HUFFMAN_ONLY        = 2;\n var Z_RLE                 = 3;\n var Z_FIXED               = 4;\n var Z_DEFAULT_STRATEGY    = 0;\n\n /* Possible values of the data_type field (though see inflate()) */\n //var Z_BINARY              = 0;\n //var Z_TEXT                = 1;\n //var Z_ASCII               = 1; // = Z_TEXT\n var Z_UNKNOWN             = 2;\n\n\n /* The deflate compression method */\n var Z_DEFLATED  = 8;\n\n /*============================================================================*/\n\n\n var MAX_MEM_LEVEL = 9;\n /* Maximum value for memLevel in deflateInit2 */\n var MAX_WBITS = 15;\n /* 32K LZ77 window */\n var DEF_MEM_LEVEL = 8;\n\n\n var LENGTH_CODES  = 29;\n /* number of length codes, not counting the special END_BLOCK code */\n var LITERALS      = 256;\n /* number of literal bytes 0..255 */\n var L_CODES       = LITERALS + 1 + LENGTH_CODES;\n /* number of Literal or Length codes, including the END_BLOCK code */\n var D_CODES       = 30;\n /* number of distance codes */\n var BL_CODES      = 19;\n /* number of codes used to transfer the bit lengths */\n var HEAP_SIZE     = 2 * L_CODES + 1;\n /* maximum heap size */\n var MAX_BITS  = 15;\n /* All codes must not exceed MAX_BITS bits */\n\n var MIN_MATCH = 3;\n var MAX_MATCH = 258;\n var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n var PRESET_DICT = 0x20;\n\n var INIT_STATE = 42;\n var EXTRA_STATE = 69;\n var NAME_STATE = 73;\n var COMMENT_STATE = 91;\n var HCRC_STATE = 103;\n var BUSY_STATE = 113;\n var FINISH_STATE = 666;\n\n var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n var BS_BLOCK_DONE     = 2; /* block flush performed */\n var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\n var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n function err(strm, errorCode) {\n   strm.msg = msg[errorCode];\n   return errorCode;\n }\n\n function rank(f) {\n   return ((f) << 1) - ((f) > 4 ? 9 : 0);\n }\n\n function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n /* =========================================================================\n  * Flush as much pending output as possible. All deflate() output goes\n  * through this function so some applications may wish to modify it\n  * to avoid allocating a large strm->output buffer and copying into it.\n  * (See also read_buf()).\n  */\n function flush_pending(strm) {\n   var s = strm.state;\n\n   //_tr_flush_bits(s);\n   var len = s.pending;\n   if (len > strm.avail_out) {\n     len = strm.avail_out;\n   }\n   if (len === 0) { return; }\n\n   utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n   strm.next_out += len;\n   s.pending_out += len;\n   strm.total_out += len;\n   strm.avail_out -= len;\n   s.pending -= len;\n   if (s.pending === 0) {\n     s.pending_out = 0;\n   }\n }\n\n\n function flush_block_only(s, last) {\n   trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n   s.block_start = s.strstart;\n   flush_pending(s.strm);\n }\n\n\n function put_byte(s, b) {\n   s.pending_buf[s.pending++] = b;\n }\n\n\n /* =========================================================================\n  * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n  * IN assertion: the stream state is correct and there is enough room in\n  * pending_buf.\n  */\n function putShortMSB(s, b) {\n //  put_byte(s, (Byte)(b >> 8));\n //  put_byte(s, (Byte)(b & 0xff));\n   s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n   s.pending_buf[s.pending++] = b & 0xff;\n }\n\n\n /* ===========================================================================\n  * Read a new buffer from the current input stream, update the adler32\n  * and total number of bytes read.  All deflate() input goes through\n  * this function so some applications may wish to modify it to avoid\n  * allocating a large strm->input buffer and copying from it.\n  * (See also flush_pending()).\n  */\n function read_buf(strm, buf, start, size) {\n   var len = strm.avail_in;\n\n   if (len > size) { len = size; }\n   if (len === 0) { return 0; }\n\n   strm.avail_in -= len;\n\n   // zmemcpy(buf, strm->next_in, len);\n   utils.arraySet(buf, strm.input, strm.next_in, len, start);\n   if (strm.state.wrap === 1) {\n     strm.adler = adler32(strm.adler, buf, len, start);\n   }\n\n   else if (strm.state.wrap === 2) {\n     strm.adler = crc32(strm.adler, buf, len, start);\n   }\n\n   strm.next_in += len;\n   strm.total_in += len;\n\n   return len;\n }\n\n\n /* ===========================================================================\n  * Set match_start to the longest match starting at the given string and\n  * return its length. Matches shorter or equal to prev_length are discarded,\n  * in which case the result is equal to prev_length and match_start is\n  * garbage.\n  * IN assertions: cur_match is the head of the hash chain for the current\n  *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n  * OUT assertion: the match length is not greater than s->lookahead.\n  */\n function longest_match(s, cur_match) {\n   var chain_length = s.max_chain_length;      /* max hash chain length */\n   var scan = s.strstart; /* current string */\n   var match;                       /* matched string */\n   var len;                           /* length of current match */\n   var best_len = s.prev_length;              /* best match length so far */\n   var nice_match = s.nice_match;             /* stop if match long enough */\n   var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n       s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n   var _win = s.window; // shortcut\n\n   var wmask = s.w_mask;\n   var prev  = s.prev;\n\n   /* Stop when cur_match becomes <= limit. To simplify the code,\n    * we prevent matches with the string of window index 0.\n    */\n\n   var strend = s.strstart + MAX_MATCH;\n   var scan_end1  = _win[scan + best_len - 1];\n   var scan_end   = _win[scan + best_len];\n\n   /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n    * It is easy to get rid of this optimization if necessary.\n    */\n   // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n   /* Do not waste too much time if we already have a good match: */\n   if (s.prev_length >= s.good_match) {\n     chain_length >>= 2;\n   }\n   /* Do not look for matches beyond the end of the input. This is necessary\n    * to make deflate deterministic.\n    */\n   if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n   // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n   do {\n     // Assert(cur_match < s->strstart, \"no future\");\n     match = cur_match;\n\n     /* Skip to next match if the match length cannot increase\n      * or if the match length is less than 2.  Note that the checks below\n      * for insufficient lookahead only occur occasionally for performance\n      * reasons.  Therefore uninitialized memory will be accessed, and\n      * conditional jumps will be made that depend on those values.\n      * However the length of the match is limited to the lookahead, so\n      * the output of deflate is not affected by the uninitialized values.\n      */\n\n     if (_win[match + best_len]     !== scan_end  ||\n         _win[match + best_len - 1] !== scan_end1 ||\n         _win[match]                !== _win[scan] ||\n         _win[++match]              !== _win[scan + 1]) {\n       continue;\n     }\n\n     /* The check at best_len-1 can be removed because it will be made\n      * again later. (This heuristic is not always a win.)\n      * It is not necessary to compare scan[2] and match[2] since they\n      * are always equal when the other bytes match, given that\n      * the hash keys are equal and that HASH_BITS >= 8.\n      */\n     scan += 2;\n     match++;\n     // Assert(*scan == *match, \"match[2]?\");\n\n     /* We check for insufficient lookahead only every 8th comparison;\n      * the 256th check will be made at strstart+258.\n      */\n     do {\n       /*jshint noempty:false*/\n     } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n              _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n              _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n              _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n              scan < strend);\n\n     // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n     len = MAX_MATCH - (strend - scan);\n     scan = strend - MAX_MATCH;\n\n     if (len > best_len) {\n       s.match_start = cur_match;\n       best_len = len;\n       if (len >= nice_match) {\n         break;\n       }\n       scan_end1  = _win[scan + best_len - 1];\n       scan_end   = _win[scan + best_len];\n     }\n   } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n   if (best_len <= s.lookahead) {\n     return best_len;\n   }\n   return s.lookahead;\n }\n\n\n /* ===========================================================================\n  * Fill the window when the lookahead becomes insufficient.\n  * Updates strstart and lookahead.\n  *\n  * IN assertion: lookahead < MIN_LOOKAHEAD\n  * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n  *    At least one byte has been read, or avail_in == 0; reads are\n  *    performed for at least two bytes (required for the zip translate_eol\n  *    option -- not supported here).\n  */\n function fill_window(s) {\n   var _w_size = s.w_size;\n   var p, n, m, more, str;\n\n   //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n   do {\n     more = s.window_size - s.lookahead - s.strstart;\n\n     // JS ints have 32 bit, block below not needed\n     /* Deal with !@#$% 64K limit: */\n     //if (sizeof(int) <= 2) {\n     //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n     //        more = wsize;\n     //\n     //  } else if (more == (unsigned)(-1)) {\n     //        /* Very unlikely, but possible on 16 bit machine if\n     //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n     //         */\n     //        more--;\n     //    }\n     //}\n\n\n     /* If the window is almost full and there is insufficient lookahead,\n      * move the upper half to the lower one to make room in the upper half.\n      */\n     if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n       utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n       s.match_start -= _w_size;\n       s.strstart -= _w_size;\n       /* we now have strstart >= MAX_DIST */\n       s.block_start -= _w_size;\n\n       /* Slide the hash table (could be avoided with 32 bit values\n        at the expense of memory usage). We slide even when level == 0\n        to keep the hash table consistent if we switch back to level > 0\n        later. (Using level 0 permanently is not an optimal usage of\n        zlib, so we don't care about this pathological case.)\n        */\n\n       n = s.hash_size;\n       p = n;\n       do {\n         m = s.head[--p];\n         s.head[p] = (m >= _w_size ? m - _w_size : 0);\n       } while (--n);\n\n       n = _w_size;\n       p = n;\n       do {\n         m = s.prev[--p];\n         s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n         /* If n is not on any hash chain, prev[n] is garbage but\n          * its value will never be used.\n          */\n       } while (--n);\n\n       more += _w_size;\n     }\n     if (s.strm.avail_in === 0) {\n       break;\n     }\n\n     /* If there was no sliding:\n      *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n      *    more == window_size - lookahead - strstart\n      * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n      * => more >= window_size - 2*WSIZE + 2\n      * In the BIG_MEM or MMAP case (not yet supported),\n      *   window_size == input_size + MIN_LOOKAHEAD  &&\n      *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n      * Otherwise, window_size == 2*WSIZE so more >= 2.\n      * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n      */\n     //Assert(more >= 2, \"more < 2\");\n     n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n     s.lookahead += n;\n\n     /* Initialize the hash value now that we have some input: */\n     if (s.lookahead + s.insert >= MIN_MATCH) {\n       str = s.strstart - s.insert;\n       s.ins_h = s.window[str];\n\n       /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n       s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n //#if MIN_MATCH != 3\n //        Call update_hash() MIN_MATCH-3 more times\n //#endif\n       while (s.insert) {\n         /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n         s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n         s.prev[str & s.w_mask] = s.head[s.ins_h];\n         s.head[s.ins_h] = str;\n         str++;\n         s.insert--;\n         if (s.lookahead + s.insert < MIN_MATCH) {\n           break;\n         }\n       }\n     }\n     /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n      * but this is not important since only literal bytes will be emitted.\n      */\n\n   } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n   /* If the WIN_INIT bytes after the end of the current data have never been\n    * written, then zero those bytes in order to avoid memory check reports of\n    * the use of uninitialized (or uninitialised as Julian writes) bytes by\n    * the longest match routines.  Update the high water mark for the next\n    * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n    * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n    */\n //  if (s.high_water < s.window_size) {\n //    var curr = s.strstart + s.lookahead;\n //    var init = 0;\n //\n //    if (s.high_water < curr) {\n //      /* Previous high water mark below current data -- zero WIN_INIT\n //       * bytes or up to end of window, whichever is less.\n //       */\n //      init = s.window_size - curr;\n //      if (init > WIN_INIT)\n //        init = WIN_INIT;\n //      zmemzero(s->window + curr, (unsigned)init);\n //      s->high_water = curr + init;\n //    }\n //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n //      /* High water mark at or above current data, but below current data\n //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n //       * to end of window, whichever is less.\n //       */\n //      init = (ulg)curr + WIN_INIT - s->high_water;\n //      if (init > s->window_size - s->high_water)\n //        init = s->window_size - s->high_water;\n //      zmemzero(s->window + s->high_water, (unsigned)init);\n //      s->high_water += init;\n //    }\n //  }\n //\n //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n //    \"not enough room for search\");\n }\n\n /* ===========================================================================\n  * Copy without compression as much as possible from the input stream, return\n  * the current block state.\n  * This function does not insert new strings in the dictionary since\n  * uncompressible data is probably not useful. This function is used\n  * only for the level=0 compression option.\n  * NOTE: this function should be optimized to avoid extra copying from\n  * window to pending_buf.\n  */\n function deflate_stored(s, flush) {\n   /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n    * to pending_buf_size, and each stored block has a 5 byte header:\n    */\n   var max_block_size = 0xffff;\n\n   if (max_block_size > s.pending_buf_size - 5) {\n     max_block_size = s.pending_buf_size - 5;\n   }\n\n   /* Copy as much as possible from input to output: */\n   for (;;) {\n     /* Fill the window as much as possible: */\n     if (s.lookahead <= 1) {\n\n       //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n       //  s->block_start >= (long)s->w_size, \"slide too late\");\n //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n //        s.block_start >= s.w_size)) {\n //        throw  new Error(\"slide too late\");\n //      }\n\n       fill_window(s);\n       if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n         return BS_NEED_MORE;\n       }\n\n       if (s.lookahead === 0) {\n         break;\n       }\n       /* flush the current block */\n     }\n     //Assert(s->block_start >= 0L, \"block gone\");\n //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n     s.strstart += s.lookahead;\n     s.lookahead = 0;\n\n     /* Emit a stored block if pending_buf will be full: */\n     var max_start = s.block_start + max_block_size;\n\n     if (s.strstart === 0 || s.strstart >= max_start) {\n       /* strstart == 0 is possible when wraparound on 16-bit machine */\n       s.lookahead = s.strstart - max_start;\n       s.strstart = max_start;\n       /*** FLUSH_BLOCK(s, 0); ***/\n       flush_block_only(s, false);\n       if (s.strm.avail_out === 0) {\n         return BS_NEED_MORE;\n       }\n       /***/\n\n\n     }\n     /* Flush if we may have to slide, otherwise block_start may become\n      * negative and the data will be gone:\n      */\n     if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n       /*** FLUSH_BLOCK(s, 0); ***/\n       flush_block_only(s, false);\n       if (s.strm.avail_out === 0) {\n         return BS_NEED_MORE;\n       }\n       /***/\n     }\n   }\n\n   s.insert = 0;\n\n   if (flush === Z_FINISH) {\n     /*** FLUSH_BLOCK(s, 1); ***/\n     flush_block_only(s, true);\n     if (s.strm.avail_out === 0) {\n       return BS_FINISH_STARTED;\n     }\n     /***/\n     return BS_FINISH_DONE;\n   }\n\n   if (s.strstart > s.block_start) {\n     /*** FLUSH_BLOCK(s, 0); ***/\n     flush_block_only(s, false);\n     if (s.strm.avail_out === 0) {\n       return BS_NEED_MORE;\n     }\n     /***/\n   }\n\n   return BS_NEED_MORE;\n }\n\n /* ===========================================================================\n  * Compress as much as possible from the input stream, return the current\n  * block state.\n  * This function does not perform lazy evaluation of matches and inserts\n  * new strings in the dictionary only for unmatched strings or for short\n  * matches. It is used only for the fast compression options.\n  */\n function deflate_fast(s, flush) {\n   var hash_head;        /* head of the hash chain */\n   var bflush;           /* set if current block must be flushed */\n\n   for (;;) {\n     /* Make sure that we always have enough lookahead, except\n      * at the end of the input file. We need MAX_MATCH bytes\n      * for the next match, plus MIN_MATCH bytes to insert the\n      * string following the next match.\n      */\n     if (s.lookahead < MIN_LOOKAHEAD) {\n       fill_window(s);\n       if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n         return BS_NEED_MORE;\n       }\n       if (s.lookahead === 0) {\n         break; /* flush the current block */\n       }\n     }\n\n     /* Insert the string window[strstart .. strstart+2] in the\n      * dictionary, and set hash_head to the head of the hash chain:\n      */\n     hash_head = 0/*NIL*/;\n     if (s.lookahead >= MIN_MATCH) {\n       /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n       s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n       hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n       s.head[s.ins_h] = s.strstart;\n       /***/\n     }\n\n     /* Find the longest match, discarding those <= prev_length.\n      * At this point we have always match_length < MIN_MATCH\n      */\n     if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n       /* To simplify the code, we prevent matches with the string\n        * of window index 0 (in particular we have to avoid a match\n        * of the string with itself at the start of the input file).\n        */\n       s.match_length = longest_match(s, hash_head);\n       /* longest_match() sets match_start */\n     }\n     if (s.match_length >= MIN_MATCH) {\n       // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n       /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                      s.match_length - MIN_MATCH, bflush); ***/\n       bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n       s.lookahead -= s.match_length;\n\n       /* Insert new strings in the hash table only if the match length\n        * is not too large. This saves time but degrades compression.\n        */\n       if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n         s.match_length--; /* string at strstart already in table */\n         do {\n           s.strstart++;\n           /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n           s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n           hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n           s.head[s.ins_h] = s.strstart;\n           /***/\n           /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n            * always MIN_MATCH bytes ahead.\n            */\n         } while (--s.match_length !== 0);\n         s.strstart++;\n       } else\n       {\n         s.strstart += s.match_length;\n         s.match_length = 0;\n         s.ins_h = s.window[s.strstart];\n         /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n         s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n //#if MIN_MATCH != 3\n //                Call UPDATE_HASH() MIN_MATCH-3 more times\n //#endif\n         /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n          * matter since it will be recomputed at next deflate call.\n          */\n       }\n     } else {\n       /* No match, output a literal byte */\n       //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n       /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n       bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n       s.lookahead--;\n       s.strstart++;\n     }\n     if (bflush) {\n       /*** FLUSH_BLOCK(s, 0); ***/\n       flush_block_only(s, false);\n       if (s.strm.avail_out === 0) {\n         return BS_NEED_MORE;\n       }\n       /***/\n     }\n   }\n   s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n   if (flush === Z_FINISH) {\n     /*** FLUSH_BLOCK(s, 1); ***/\n     flush_block_only(s, true);\n     if (s.strm.avail_out === 0) {\n       return BS_FINISH_STARTED;\n     }\n     /***/\n     return BS_FINISH_DONE;\n   }\n   if (s.last_lit) {\n     /*** FLUSH_BLOCK(s, 0); ***/\n     flush_block_only(s, false);\n     if (s.strm.avail_out === 0) {\n       return BS_NEED_MORE;\n     }\n     /***/\n   }\n   return BS_BLOCK_DONE;\n }\n\n /* ===========================================================================\n  * Same as above, but achieves better compression. We use a lazy\n  * evaluation for matches: a match is finally adopted only if there is\n  * no better match at the next window position.\n  */\n function deflate_slow(s, flush) {\n   var hash_head;          /* head of hash chain */\n   var bflush;              /* set if current block must be flushed */\n\n   var max_insert;\n\n   /* Process the input block. */\n   for (;;) {\n     /* Make sure that we always have enough lookahead, except\n      * at the end of the input file. We need MAX_MATCH bytes\n      * for the next match, plus MIN_MATCH bytes to insert the\n      * string following the next match.\n      */\n     if (s.lookahead < MIN_LOOKAHEAD) {\n       fill_window(s);\n       if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n         return BS_NEED_MORE;\n       }\n       if (s.lookahead === 0) { break; } /* flush the current block */\n     }\n\n     /* Insert the string window[strstart .. strstart+2] in the\n      * dictionary, and set hash_head to the head of the hash chain:\n      */\n     hash_head = 0/*NIL*/;\n     if (s.lookahead >= MIN_MATCH) {\n       /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n       s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n       hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n       s.head[s.ins_h] = s.strstart;\n       /***/\n     }\n\n     /* Find the longest match, discarding those <= prev_length.\n      */\n     s.prev_length = s.match_length;\n     s.prev_match = s.match_start;\n     s.match_length = MIN_MATCH - 1;\n\n     if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n         s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n       /* To simplify the code, we prevent matches with the string\n        * of window index 0 (in particular we have to avoid a match\n        * of the string with itself at the start of the input file).\n        */\n       s.match_length = longest_match(s, hash_head);\n       /* longest_match() sets match_start */\n\n       if (s.match_length <= 5 &&\n          (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n         /* If prev_match is also MIN_MATCH, match_start is garbage\n          * but we will ignore the current match anyway.\n          */\n         s.match_length = MIN_MATCH - 1;\n       }\n     }\n     /* If there was a match at the previous step and the current\n      * match is not better, output the previous match:\n      */\n     if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n       max_insert = s.strstart + s.lookahead - MIN_MATCH;\n       /* Do not insert strings in hash table beyond this. */\n\n       //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n       /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                      s.prev_length - MIN_MATCH, bflush);***/\n       bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n       /* Insert in hash table all strings up to the end of the match.\n        * strstart-1 and strstart are already inserted. If there is not\n        * enough lookahead, the last two strings are not inserted in\n        * the hash table.\n        */\n       s.lookahead -= s.prev_length - 1;\n       s.prev_length -= 2;\n       do {\n         if (++s.strstart <= max_insert) {\n           /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n           s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n           hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n           s.head[s.ins_h] = s.strstart;\n           /***/\n         }\n       } while (--s.prev_length !== 0);\n       s.match_available = 0;\n       s.match_length = MIN_MATCH - 1;\n       s.strstart++;\n\n       if (bflush) {\n         /*** FLUSH_BLOCK(s, 0); ***/\n         flush_block_only(s, false);\n         if (s.strm.avail_out === 0) {\n           return BS_NEED_MORE;\n         }\n         /***/\n       }\n\n     } else if (s.match_available) {\n       /* If there was no match at the previous position, output a\n        * single literal. If there was a match but the current match\n        * is longer, truncate the previous match to a single literal.\n        */\n       //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n       /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n       bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n       if (bflush) {\n         /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n         flush_block_only(s, false);\n         /***/\n       }\n       s.strstart++;\n       s.lookahead--;\n       if (s.strm.avail_out === 0) {\n         return BS_NEED_MORE;\n       }\n     } else {\n       /* There is no previous match to compare with, wait for\n        * the next step to decide.\n        */\n       s.match_available = 1;\n       s.strstart++;\n       s.lookahead--;\n     }\n   }\n   //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n   if (s.match_available) {\n     //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n     /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n     bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n     s.match_available = 0;\n   }\n   s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n   if (flush === Z_FINISH) {\n     /*** FLUSH_BLOCK(s, 1); ***/\n     flush_block_only(s, true);\n     if (s.strm.avail_out === 0) {\n       return BS_FINISH_STARTED;\n     }\n     /***/\n     return BS_FINISH_DONE;\n   }\n   if (s.last_lit) {\n     /*** FLUSH_BLOCK(s, 0); ***/\n     flush_block_only(s, false);\n     if (s.strm.avail_out === 0) {\n       return BS_NEED_MORE;\n     }\n     /***/\n   }\n\n   return BS_BLOCK_DONE;\n }\n\n\n /* ===========================================================================\n  * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n  * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n  * deflate switches away from Z_RLE.)\n  */\n function deflate_rle(s, flush) {\n   var bflush;            /* set if current block must be flushed */\n   var prev;              /* byte at distance one to match */\n   var scan, strend;      /* scan goes up to strend for length of run */\n\n   var _win = s.window;\n\n   for (;;) {\n     /* Make sure that we always have enough lookahead, except\n      * at the end of the input file. We need MAX_MATCH bytes\n      * for the longest run, plus one for the unrolled loop.\n      */\n     if (s.lookahead <= MAX_MATCH) {\n       fill_window(s);\n       if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n         return BS_NEED_MORE;\n       }\n       if (s.lookahead === 0) { break; } /* flush the current block */\n     }\n\n     /* See how many times the previous byte repeats */\n     s.match_length = 0;\n     if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n       scan = s.strstart - 1;\n       prev = _win[scan];\n       if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n         strend = s.strstart + MAX_MATCH;\n         do {\n           /*jshint noempty:false*/\n         } while (prev === _win[++scan] && prev === _win[++scan] &&\n                  prev === _win[++scan] && prev === _win[++scan] &&\n                  prev === _win[++scan] && prev === _win[++scan] &&\n                  prev === _win[++scan] && prev === _win[++scan] &&\n                  scan < strend);\n         s.match_length = MAX_MATCH - (strend - scan);\n         if (s.match_length > s.lookahead) {\n           s.match_length = s.lookahead;\n         }\n       }\n       //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n     }\n\n     /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n     if (s.match_length >= MIN_MATCH) {\n       //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n       /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n       bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n       s.lookahead -= s.match_length;\n       s.strstart += s.match_length;\n       s.match_length = 0;\n     } else {\n       /* No match, output a literal byte */\n       //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n       /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n       bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n       s.lookahead--;\n       s.strstart++;\n     }\n     if (bflush) {\n       /*** FLUSH_BLOCK(s, 0); ***/\n       flush_block_only(s, false);\n       if (s.strm.avail_out === 0) {\n         return BS_NEED_MORE;\n       }\n       /***/\n     }\n   }\n   s.insert = 0;\n   if (flush === Z_FINISH) {\n     /*** FLUSH_BLOCK(s, 1); ***/\n     flush_block_only(s, true);\n     if (s.strm.avail_out === 0) {\n       return BS_FINISH_STARTED;\n     }\n     /***/\n     return BS_FINISH_DONE;\n   }\n   if (s.last_lit) {\n     /*** FLUSH_BLOCK(s, 0); ***/\n     flush_block_only(s, false);\n     if (s.strm.avail_out === 0) {\n       return BS_NEED_MORE;\n     }\n     /***/\n   }\n   return BS_BLOCK_DONE;\n }\n\n /* ===========================================================================\n  * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n  * (It will be regenerated if this run of deflate switches away from Huffman.)\n  */\n function deflate_huff(s, flush) {\n   var bflush;             /* set if current block must be flushed */\n\n   for (;;) {\n     /* Make sure that we have a literal to write. */\n     if (s.lookahead === 0) {\n       fill_window(s);\n       if (s.lookahead === 0) {\n         if (flush === Z_NO_FLUSH) {\n           return BS_NEED_MORE;\n         }\n         break;      /* flush the current block */\n       }\n     }\n\n     /* Output a literal byte */\n     s.match_length = 0;\n     //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n     /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n     bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n     s.lookahead--;\n     s.strstart++;\n     if (bflush) {\n       /*** FLUSH_BLOCK(s, 0); ***/\n       flush_block_only(s, false);\n       if (s.strm.avail_out === 0) {\n         return BS_NEED_MORE;\n       }\n       /***/\n     }\n   }\n   s.insert = 0;\n   if (flush === Z_FINISH) {\n     /*** FLUSH_BLOCK(s, 1); ***/\n     flush_block_only(s, true);\n     if (s.strm.avail_out === 0) {\n       return BS_FINISH_STARTED;\n     }\n     /***/\n     return BS_FINISH_DONE;\n   }\n   if (s.last_lit) {\n     /*** FLUSH_BLOCK(s, 0); ***/\n     flush_block_only(s, false);\n     if (s.strm.avail_out === 0) {\n       return BS_NEED_MORE;\n     }\n     /***/\n   }\n   return BS_BLOCK_DONE;\n }\n\n /* Values for max_lazy_match, good_match and max_chain_length, depending on\n  * the desired pack level (0..9). The values given below have been tuned to\n  * exclude worst case performance for pathological files. Better values may be\n  * found for specific files.\n  */\n function Config(good_length, max_lazy, nice_length, max_chain, func) {\n   this.good_length = good_length;\n   this.max_lazy = max_lazy;\n   this.nice_length = nice_length;\n   this.max_chain = max_chain;\n   this.func = func;\n }\n\n var configuration_table;\n\n configuration_table = [\n   /*      good lazy nice chain */\n   new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n   new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n   new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n   new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n   new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n   new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n   new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n   new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n   new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n   new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n ];\n\n\n /* ===========================================================================\n  * Initialize the \"longest match\" routines for a new zlib stream\n  */\n function lm_init(s) {\n   s.window_size = 2 * s.w_size;\n\n   /*** CLEAR_HASH(s); ***/\n   zero(s.head); // Fill with NIL (= 0);\n\n   /* Set the default configuration parameters:\n    */\n   s.max_lazy_match = configuration_table[s.level].max_lazy;\n   s.good_match = configuration_table[s.level].good_length;\n   s.nice_match = configuration_table[s.level].nice_length;\n   s.max_chain_length = configuration_table[s.level].max_chain;\n\n   s.strstart = 0;\n   s.block_start = 0;\n   s.lookahead = 0;\n   s.insert = 0;\n   s.match_length = s.prev_length = MIN_MATCH - 1;\n   s.match_available = 0;\n   s.ins_h = 0;\n }\n\n\n function DeflateState() {\n   this.strm = null;            /* pointer back to this zlib stream */\n   this.status = 0;            /* as the name implies */\n   this.pending_buf = null;      /* output still pending */\n   this.pending_buf_size = 0;  /* size of pending_buf */\n   this.pending_out = 0;       /* next pending byte to output to the stream */\n   this.pending = 0;           /* nb of bytes in the pending buffer */\n   this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n   this.gzhead = null;         /* gzip header information to write */\n   this.gzindex = 0;           /* where in extra, name, or comment */\n   this.method = Z_DEFLATED; /* can only be DEFLATED */\n   this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n   this.w_size = 0;  /* LZ77 window size (32K by default) */\n   this.w_bits = 0;  /* log2(w_size)  (8..16) */\n   this.w_mask = 0;  /* w_size - 1 */\n\n   this.window = null;\n   /* Sliding window. Input bytes are read into the second half of the window,\n    * and move to the first half later to keep a dictionary of at least wSize\n    * bytes. With this organization, matches are limited to a distance of\n    * wSize-MAX_MATCH bytes, but this ensures that IO is always\n    * performed with a length multiple of the block size.\n    */\n\n   this.window_size = 0;\n   /* Actual size of window: 2*wSize, except when the user input buffer\n    * is directly used as sliding window.\n    */\n\n   this.prev = null;\n   /* Link to older string with same hash index. To limit the size of this\n    * array to 64K, this link is maintained only for the last 32K strings.\n    * An index in this array is thus a window index modulo 32K.\n    */\n\n   this.head = null;   /* Heads of the hash chains or NIL. */\n\n   this.ins_h = 0;       /* hash index of string to be inserted */\n   this.hash_size = 0;   /* number of elements in hash table */\n   this.hash_bits = 0;   /* log2(hash_size) */\n   this.hash_mask = 0;   /* hash_size-1 */\n\n   this.hash_shift = 0;\n   /* Number of bits by which ins_h must be shifted at each input\n    * step. It must be such that after MIN_MATCH steps, the oldest\n    * byte no longer takes part in the hash key, that is:\n    *   hash_shift * MIN_MATCH >= hash_bits\n    */\n\n   this.block_start = 0;\n   /* Window position at the beginning of the current output block. Gets\n    * negative when the window is moved backwards.\n    */\n\n   this.match_length = 0;      /* length of best match */\n   this.prev_match = 0;        /* previous match */\n   this.match_available = 0;   /* set if previous match exists */\n   this.strstart = 0;          /* start of string to insert */\n   this.match_start = 0;       /* start of matching string */\n   this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n   this.prev_length = 0;\n   /* Length of the best match at previous step. Matches not greater than this\n    * are discarded. This is used in the lazy match evaluation.\n    */\n\n   this.max_chain_length = 0;\n   /* To speed up deflation, hash chains are never searched beyond this\n    * length.  A higher limit improves compression ratio but degrades the\n    * speed.\n    */\n\n   this.max_lazy_match = 0;\n   /* Attempt to find a better match only when the current match is strictly\n    * smaller than this value. This mechanism is used only for compression\n    * levels >= 4.\n    */\n   // That's alias to max_lazy_match, don't use directly\n   //this.max_insert_length = 0;\n   /* Insert new strings in the hash table only if the match length is not\n    * greater than this length. This saves time but degrades compression.\n    * max_insert_length is used only for compression levels <= 3.\n    */\n\n   this.level = 0;     /* compression level (1..9) */\n   this.strategy = 0;  /* favor or force Huffman coding*/\n\n   this.good_match = 0;\n   /* Use a faster search when the previous match is longer than this */\n\n   this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n               /* used by trees.c: */\n\n   /* Didn't use ct_data typedef below to suppress compiler warning */\n\n   // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n   // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n   // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n   // Use flat array of DOUBLE size, with interleaved fata,\n   // because JS does not support effective\n   this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n   this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n   this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n   zero(this.dyn_ltree);\n   zero(this.dyn_dtree);\n   zero(this.bl_tree);\n\n   this.l_desc   = null;         /* desc. for literal tree */\n   this.d_desc   = null;         /* desc. for distance tree */\n   this.bl_desc  = null;         /* desc. for bit length tree */\n\n   //ush bl_count[MAX_BITS+1];\n   this.bl_count = new utils.Buf16(MAX_BITS + 1);\n   /* number of codes at each bit length for an optimal tree */\n\n   //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n   this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n   zero(this.heap);\n\n   this.heap_len = 0;               /* number of elements in the heap */\n   this.heap_max = 0;               /* element of largest frequency */\n   /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n    * The same heap array is used to build all trees.\n    */\n\n   this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n   zero(this.depth);\n   /* Depth of each subtree used as tie breaker for trees of equal frequency\n    */\n\n   this.l_buf = 0;          /* buffer index for literals or lengths */\n\n   this.lit_bufsize = 0;\n   /* Size of match buffer for literals/lengths.  There are 4 reasons for\n    * limiting lit_bufsize to 64K:\n    *   - frequencies can be kept in 16 bit counters\n    *   - if compression is not successful for the first block, all input\n    *     data is still in the window so we can still emit a stored block even\n    *     when input comes from standard input.  (This can also be done for\n    *     all blocks if lit_bufsize is not greater than 32K.)\n    *   - if compression is not successful for a file smaller than 64K, we can\n    *     even emit a stored file instead of a stored block (saving 5 bytes).\n    *     This is applicable only for zip (not gzip or zlib).\n    *   - creating new Huffman trees less frequently may not provide fast\n    *     adaptation to changes in the input data statistics. (Take for\n    *     example a binary file with poorly compressible code followed by\n    *     a highly compressible string table.) Smaller buffer sizes give\n    *     fast adaptation but have of course the overhead of transmitting\n    *     trees more frequently.\n    *   - I can't count above 4\n    */\n\n   this.last_lit = 0;      /* running index in l_buf */\n\n   this.d_buf = 0;\n   /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n    * the same number of elements. To use different lengths, an extra flag\n    * array would be necessary.\n    */\n\n   this.opt_len = 0;       /* bit length of current block with optimal trees */\n   this.static_len = 0;    /* bit length of current block with static trees */\n   this.matches = 0;       /* number of string matches in current block */\n   this.insert = 0;        /* bytes at end of window left to insert */\n\n\n   this.bi_buf = 0;\n   /* Output buffer. bits are inserted starting at the bottom (least\n    * significant bits).\n    */\n   this.bi_valid = 0;\n   /* Number of valid bits in bi_buf.  All bits above the last valid bit\n    * are always zero.\n    */\n\n   // Used for window memory init. We safely ignore it for JS. That makes\n   // sense only for pointers and memory check tools.\n   //this.high_water = 0;\n   /* High water mark offset in window for initialized bytes -- bytes above\n    * this are set to zero in order to avoid memory check warnings when\n    * longest match routines access bytes past the input.  This is then\n    * updated to the new high water mark.\n    */\n }\n\n\n function deflateResetKeep(strm) {\n   var s;\n\n   if (!strm || !strm.state) {\n     return err(strm, Z_STREAM_ERROR);\n   }\n\n   strm.total_in = strm.total_out = 0;\n   strm.data_type = Z_UNKNOWN;\n\n   s = strm.state;\n   s.pending = 0;\n   s.pending_out = 0;\n\n   if (s.wrap < 0) {\n     s.wrap = -s.wrap;\n     /* was made negative by deflate(..., Z_FINISH); */\n   }\n   s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n   strm.adler = (s.wrap === 2) ?\n     0  // crc32(0, Z_NULL, 0)\n   :\n     1; // adler32(0, Z_NULL, 0)\n   s.last_flush = Z_NO_FLUSH;\n   trees._tr_init(s);\n   return Z_OK;\n }\n\n\n function deflateReset(strm) {\n   var ret = deflateResetKeep(strm);\n   if (ret === Z_OK) {\n     lm_init(strm.state);\n   }\n   return ret;\n }\n\n\n function deflateSetHeader(strm, head) {\n   if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n   if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n   strm.state.gzhead = head;\n   return Z_OK;\n }\n\n\n function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n   if (!strm) { // === Z_NULL\n     return Z_STREAM_ERROR;\n   }\n   var wrap = 1;\n\n   if (level === Z_DEFAULT_COMPRESSION) {\n     level = 6;\n   }\n\n   if (windowBits < 0) { /* suppress zlib wrapper */\n     wrap = 0;\n     windowBits = -windowBits;\n   }\n\n   else if (windowBits > 15) {\n     wrap = 2;           /* write gzip wrapper instead */\n     windowBits -= 16;\n   }\n\n\n   if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n     windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n     strategy < 0 || strategy > Z_FIXED) {\n     return err(strm, Z_STREAM_ERROR);\n   }\n\n\n   if (windowBits === 8) {\n     windowBits = 9;\n   }\n   /* until 256-byte window bug fixed */\n\n   var s = new DeflateState();\n\n   strm.state = s;\n   s.strm = strm;\n\n   s.wrap = wrap;\n   s.gzhead = null;\n   s.w_bits = windowBits;\n   s.w_size = 1 << s.w_bits;\n   s.w_mask = s.w_size - 1;\n\n   s.hash_bits = memLevel + 7;\n   s.hash_size = 1 << s.hash_bits;\n   s.hash_mask = s.hash_size - 1;\n   s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n   s.window = new utils.Buf8(s.w_size * 2);\n   s.head = new utils.Buf16(s.hash_size);\n   s.prev = new utils.Buf16(s.w_size);\n\n   // Don't need mem init magic for JS.\n   //s.high_water = 0;  /* nothing written to s->window yet */\n\n   s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n   s.pending_buf_size = s.lit_bufsize * 4;\n\n   //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n   //s->pending_buf = (uchf *) overlay;\n   s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n   // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n   //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n   s.d_buf = 1 * s.lit_bufsize;\n\n   //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n   s.l_buf = (1 + 2) * s.lit_bufsize;\n\n   s.level = level;\n   s.strategy = strategy;\n   s.method = method;\n\n   return deflateReset(strm);\n }\n\n function deflateInit(strm, level) {\n   return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n }\n\n\n function deflate(strm, flush) {\n   var old_flush, s;\n   var beg, val; // for gzip header write only\n\n   if (!strm || !strm.state ||\n     flush > Z_BLOCK || flush < 0) {\n     return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n   }\n\n   s = strm.state;\n\n   if (!strm.output ||\n       (!strm.input && strm.avail_in !== 0) ||\n       (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n     return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n   }\n\n   s.strm = strm; /* just in case */\n   old_flush = s.last_flush;\n   s.last_flush = flush;\n\n   /* Write the header */\n   if (s.status === INIT_STATE) {\n\n     if (s.wrap === 2) { // GZIP header\n       strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n       put_byte(s, 31);\n       put_byte(s, 139);\n       put_byte(s, 8);\n       if (!s.gzhead) { // s->gzhead == Z_NULL\n         put_byte(s, 0);\n         put_byte(s, 0);\n         put_byte(s, 0);\n         put_byte(s, 0);\n         put_byte(s, 0);\n         put_byte(s, s.level === 9 ? 2 :\n                     (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                      4 : 0));\n         put_byte(s, OS_CODE);\n         s.status = BUSY_STATE;\n       }\n       else {\n         put_byte(s, (s.gzhead.text ? 1 : 0) +\n                     (s.gzhead.hcrc ? 2 : 0) +\n                     (!s.gzhead.extra ? 0 : 4) +\n                     (!s.gzhead.name ? 0 : 8) +\n                     (!s.gzhead.comment ? 0 : 16)\n         );\n         put_byte(s, s.gzhead.time & 0xff);\n         put_byte(s, (s.gzhead.time >> 8) & 0xff);\n         put_byte(s, (s.gzhead.time >> 16) & 0xff);\n         put_byte(s, (s.gzhead.time >> 24) & 0xff);\n         put_byte(s, s.level === 9 ? 2 :\n                     (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                      4 : 0));\n         put_byte(s, s.gzhead.os & 0xff);\n         if (s.gzhead.extra && s.gzhead.extra.length) {\n           put_byte(s, s.gzhead.extra.length & 0xff);\n           put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n         }\n         if (s.gzhead.hcrc) {\n           strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n         }\n         s.gzindex = 0;\n         s.status = EXTRA_STATE;\n       }\n     }\n     else // DEFLATE header\n     {\n       var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n       var level_flags = -1;\n\n       if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n         level_flags = 0;\n       } else if (s.level < 6) {\n         level_flags = 1;\n       } else if (s.level === 6) {\n         level_flags = 2;\n       } else {\n         level_flags = 3;\n       }\n       header |= (level_flags << 6);\n       if (s.strstart !== 0) { header |= PRESET_DICT; }\n       header += 31 - (header % 31);\n\n       s.status = BUSY_STATE;\n       putShortMSB(s, header);\n\n       /* Save the adler32 of the preset dictionary: */\n       if (s.strstart !== 0) {\n         putShortMSB(s, strm.adler >>> 16);\n         putShortMSB(s, strm.adler & 0xffff);\n       }\n       strm.adler = 1; // adler32(0L, Z_NULL, 0);\n     }\n   }\n\n //#ifdef GZIP\n   if (s.status === EXTRA_STATE) {\n     if (s.gzhead.extra/* != Z_NULL*/) {\n       beg = s.pending;  /* start of bytes to update crc */\n\n       while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n         if (s.pending === s.pending_buf_size) {\n           if (s.gzhead.hcrc && s.pending > beg) {\n             strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n           }\n           flush_pending(strm);\n           beg = s.pending;\n           if (s.pending === s.pending_buf_size) {\n             break;\n           }\n         }\n         put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n         s.gzindex++;\n       }\n       if (s.gzhead.hcrc && s.pending > beg) {\n         strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n       }\n       if (s.gzindex === s.gzhead.extra.length) {\n         s.gzindex = 0;\n         s.status = NAME_STATE;\n       }\n     }\n     else {\n       s.status = NAME_STATE;\n     }\n   }\n   if (s.status === NAME_STATE) {\n     if (s.gzhead.name/* != Z_NULL*/) {\n       beg = s.pending;  /* start of bytes to update crc */\n       //int val;\n\n       do {\n         if (s.pending === s.pending_buf_size) {\n           if (s.gzhead.hcrc && s.pending > beg) {\n             strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n           }\n           flush_pending(strm);\n           beg = s.pending;\n           if (s.pending === s.pending_buf_size) {\n             val = 1;\n             break;\n           }\n         }\n         // JS specific: little magic to add zero terminator to end of string\n         if (s.gzindex < s.gzhead.name.length) {\n           val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n         } else {\n           val = 0;\n         }\n         put_byte(s, val);\n       } while (val !== 0);\n\n       if (s.gzhead.hcrc && s.pending > beg) {\n         strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n       }\n       if (val === 0) {\n         s.gzindex = 0;\n         s.status = COMMENT_STATE;\n       }\n     }\n     else {\n       s.status = COMMENT_STATE;\n     }\n   }\n   if (s.status === COMMENT_STATE) {\n     if (s.gzhead.comment/* != Z_NULL*/) {\n       beg = s.pending;  /* start of bytes to update crc */\n       //int val;\n\n       do {\n         if (s.pending === s.pending_buf_size) {\n           if (s.gzhead.hcrc && s.pending > beg) {\n             strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n           }\n           flush_pending(strm);\n           beg = s.pending;\n           if (s.pending === s.pending_buf_size) {\n             val = 1;\n             break;\n           }\n         }\n         // JS specific: little magic to add zero terminator to end of string\n         if (s.gzindex < s.gzhead.comment.length) {\n           val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n         } else {\n           val = 0;\n         }\n         put_byte(s, val);\n       } while (val !== 0);\n\n       if (s.gzhead.hcrc && s.pending > beg) {\n         strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n       }\n       if (val === 0) {\n         s.status = HCRC_STATE;\n       }\n     }\n     else {\n       s.status = HCRC_STATE;\n     }\n   }\n   if (s.status === HCRC_STATE) {\n     if (s.gzhead.hcrc) {\n       if (s.pending + 2 > s.pending_buf_size) {\n         flush_pending(strm);\n       }\n       if (s.pending + 2 <= s.pending_buf_size) {\n         put_byte(s, strm.adler & 0xff);\n         put_byte(s, (strm.adler >> 8) & 0xff);\n         strm.adler = 0; //crc32(0L, Z_NULL, 0);\n         s.status = BUSY_STATE;\n       }\n     }\n     else {\n       s.status = BUSY_STATE;\n     }\n   }\n //#endif\n\n   /* Flush as much pending output as possible */\n   if (s.pending !== 0) {\n     flush_pending(strm);\n     if (strm.avail_out === 0) {\n       /* Since avail_out is 0, deflate will be called again with\n        * more output space, but possibly with both pending and\n        * avail_in equal to zero. There won't be anything to do,\n        * but this is not an error situation so make sure we\n        * return OK instead of BUF_ERROR at next call of deflate:\n        */\n       s.last_flush = -1;\n       return Z_OK;\n     }\n\n     /* Make sure there is something to do and avoid duplicate consecutive\n      * flushes. For repeated and useless calls with Z_FINISH, we keep\n      * returning Z_STREAM_END instead of Z_BUF_ERROR.\n      */\n   } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n     flush !== Z_FINISH) {\n     return err(strm, Z_BUF_ERROR);\n   }\n\n   /* User must not provide more input after the first FINISH: */\n   if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n     return err(strm, Z_BUF_ERROR);\n   }\n\n   /* Start a new block or continue the current one.\n    */\n   if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n     (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n     var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n       (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n         configuration_table[s.level].func(s, flush));\n\n     if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n       s.status = FINISH_STATE;\n     }\n     if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n       if (strm.avail_out === 0) {\n         s.last_flush = -1;\n         /* avoid BUF_ERROR next call, see above */\n       }\n       return Z_OK;\n       /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n        * of deflate should use the same flush parameter to make sure\n        * that the flush is complete. So we don't have to output an\n        * empty block here, this will be done at next call. This also\n        * ensures that for a very small output buffer, we emit at most\n        * one empty block.\n        */\n     }\n     if (bstate === BS_BLOCK_DONE) {\n       if (flush === Z_PARTIAL_FLUSH) {\n         trees._tr_align(s);\n       }\n       else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n         trees._tr_stored_block(s, 0, 0, false);\n         /* For a full flush, this empty block will be recognized\n          * as a special marker by inflate_sync().\n          */\n         if (flush === Z_FULL_FLUSH) {\n           /*** CLEAR_HASH(s); ***/             /* forget history */\n           zero(s.head); // Fill with NIL (= 0);\n\n           if (s.lookahead === 0) {\n             s.strstart = 0;\n             s.block_start = 0;\n             s.insert = 0;\n           }\n         }\n       }\n       flush_pending(strm);\n       if (strm.avail_out === 0) {\n         s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n         return Z_OK;\n       }\n     }\n   }\n   //Assert(strm->avail_out > 0, \"bug2\");\n   //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n   if (flush !== Z_FINISH) { return Z_OK; }\n   if (s.wrap <= 0) { return Z_STREAM_END; }\n\n   /* Write the trailer */\n   if (s.wrap === 2) {\n     put_byte(s, strm.adler & 0xff);\n     put_byte(s, (strm.adler >> 8) & 0xff);\n     put_byte(s, (strm.adler >> 16) & 0xff);\n     put_byte(s, (strm.adler >> 24) & 0xff);\n     put_byte(s, strm.total_in & 0xff);\n     put_byte(s, (strm.total_in >> 8) & 0xff);\n     put_byte(s, (strm.total_in >> 16) & 0xff);\n     put_byte(s, (strm.total_in >> 24) & 0xff);\n   }\n   else\n   {\n     putShortMSB(s, strm.adler >>> 16);\n     putShortMSB(s, strm.adler & 0xffff);\n   }\n\n   flush_pending(strm);\n   /* If avail_out is zero, the application will call deflate again\n    * to flush the rest.\n    */\n   if (s.wrap > 0) { s.wrap = -s.wrap; }\n   /* write the trailer only once! */\n   return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n }\n\n function deflateEnd(strm) {\n   var status;\n\n   if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n     return Z_STREAM_ERROR;\n   }\n\n   status = strm.state.status;\n   if (status !== INIT_STATE &&\n     status !== EXTRA_STATE &&\n     status !== NAME_STATE &&\n     status !== COMMENT_STATE &&\n     status !== HCRC_STATE &&\n     status !== BUSY_STATE &&\n     status !== FINISH_STATE\n   ) {\n     return err(strm, Z_STREAM_ERROR);\n   }\n\n   strm.state = null;\n\n   return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n }\n\n\n /* =========================================================================\n  * Initializes the compression dictionary from the given byte\n  * sequence without producing any compressed output.\n  */\n function deflateSetDictionary(strm, dictionary) {\n   var dictLength = dictionary.length;\n\n   var s;\n   var str, n;\n   var wrap;\n   var avail;\n   var next;\n   var input;\n   var tmpDict;\n\n   if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n     return Z_STREAM_ERROR;\n   }\n\n   s = strm.state;\n   wrap = s.wrap;\n\n   if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n     return Z_STREAM_ERROR;\n   }\n\n   /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n   if (wrap === 1) {\n     /* adler32(strm->adler, dictionary, dictLength); */\n     strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n   }\n\n   s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n   /* if dictionary would fill window, just replace the history */\n   if (dictLength >= s.w_size) {\n     if (wrap === 0) {            /* already empty otherwise */\n       /*** CLEAR_HASH(s); ***/\n       zero(s.head); // Fill with NIL (= 0);\n       s.strstart = 0;\n       s.block_start = 0;\n       s.insert = 0;\n     }\n     /* use the tail */\n     // dictionary = dictionary.slice(dictLength - s.w_size);\n     tmpDict = new utils.Buf8(s.w_size);\n     utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n     dictionary = tmpDict;\n     dictLength = s.w_size;\n   }\n   /* insert dictionary into window and hash */\n   avail = strm.avail_in;\n   next = strm.next_in;\n   input = strm.input;\n   strm.avail_in = dictLength;\n   strm.next_in = 0;\n   strm.input = dictionary;\n   fill_window(s);\n   while (s.lookahead >= MIN_MATCH) {\n     str = s.strstart;\n     n = s.lookahead - (MIN_MATCH - 1);\n     do {\n       /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n       s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n       s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n       s.head[s.ins_h] = str;\n       str++;\n     } while (--n);\n     s.strstart = str;\n     s.lookahead = MIN_MATCH - 1;\n     fill_window(s);\n   }\n   s.strstart += s.lookahead;\n   s.block_start = s.strstart;\n   s.insert = s.lookahead;\n   s.lookahead = 0;\n   s.match_length = s.prev_length = MIN_MATCH - 1;\n   s.match_available = 0;\n   strm.next_in = next;\n   strm.input = input;\n   strm.avail_in = avail;\n   s.wrap = wrap;\n   return Z_OK;\n }\n\n\n exports.deflateInit = deflateInit;\n exports.deflateInit2 = deflateInit2;\n exports.deflateReset = deflateReset;\n exports.deflateResetKeep = deflateResetKeep;\n exports.deflateSetHeader = deflateSetHeader;\n exports.deflate = deflate;\n exports.deflateEnd = deflateEnd;\n exports.deflateSetDictionary = deflateSetDictionary;\n exports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n /* Not implemented\n exports.deflateBound = deflateBound;\n exports.deflateCopy = deflateCopy;\n exports.deflateParams = deflateParams;\n exports.deflatePending = deflatePending;\n exports.deflatePrime = deflatePrime;\n exports.deflateTune = deflateTune;\n */\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n_deflateInit = module.exports.deflateInit;\n_deflateInit2 = module.exports.deflateInit2;\n_deflateReset = module.exports.deflateReset;\n_deflateResetKeep = module.exports.deflateResetKeep;\n_deflateSetHeader = module.exports.deflateSetHeader;\n_deflate = module.exports.deflate;\n_deflateEnd = module.exports.deflateEnd;\n_deflateSetDictionary = module.exports.deflateSetDictionary;\n_deflateInfo = module.exports.deflateInfo;\n\n}, () => ({\n  '../utils/common': _req,\n  './trees': _req0,\n  './adler32': _req1,\n  './crc32': _req2,\n  './messages': _req3,\n}));\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}