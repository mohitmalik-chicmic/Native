{"version":3,"sources":["file:///Users/chicmic/Documents/InhouseCOCOS/ZipExtractor/node_modules/pako/lib/zlib/inffast.js"],"names":["_cjsLoader","__cjsMetaURL","url","define","exports","require","module","__filename","__dirname","BAD","TYPE","inflate_fast","strm","start","state","_in","last","_out","beg","end","dmax","wsize","whave","wnext","s_window","hold","bits","lcode","dcode","lmask","dmask","here","op","len","dist","from","from_source","input","output","next_in","avail_in","next_out","avail_out","window","lencode","distcode","lenbits","distbits","top","dolen","dodist","msg","mode","sane","_cjsExports"],"mappings":"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","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nlet _cjsExports;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n 'use strict';\n\n // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n //\n // This software is provided 'as-is', without any express or implied\n // warranty. In no event will the authors be held liable for any damages\n // arising from the use of this software.\n //\n // Permission is granted to anyone to use this software for any purpose,\n // including commercial applications, and to alter it and redistribute it\n // freely, subject to the following restrictions:\n //\n // 1. The origin of this software must not be misrepresented; you must not\n //   claim that you wrote the original software. If you use this software\n //   in a product, an acknowledgment in the product documentation would be\n //   appreciated but is not required.\n // 2. Altered source versions must be plainly marked as such, and must not be\n //   misrepresented as being the original software.\n // 3. This notice may not be removed or altered from any source distribution.\n\n // See state defs from inflate.js\n var BAD = 30;       /* got a data error -- remain here until reset */\n var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n /*\n    Decode literal, length, and distance codes and write out the resulting\n    literal and match bytes until either not enough input or output is\n    available, an end-of-block is encountered, or a data error is encountered.\n    When large enough input and output buffers are supplied to inflate(), for\n    example, a 16K input buffer and a 64K output buffer, more than 95% of the\n    inflate execution time is spent in this routine.\n\n    Entry assumptions:\n\n         state.mode === LEN\n         strm.avail_in >= 6\n         strm.avail_out >= 258\n         start >= strm.avail_out\n         state.bits < 8\n\n    On return, state.mode is one of:\n\n         LEN -- ran out of enough output space or enough available input\n         TYPE -- reached end of block code, inflate() to interpret next block\n         BAD -- error in block data\n\n    Notes:\n\n     - The maximum input bits used by a length/distance pair is 15 bits for the\n       length code, 5 bits for the length extra, 15 bits for the distance code,\n       and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n       Therefore if strm.avail_in >= 6, then there is enough input to avoid\n       checking for available input while decoding.\n\n     - The maximum bytes that a single length/distance pair can output is 258\n       bytes, which is the maximum length that can be coded.  inflate_fast()\n       requires strm.avail_out >= 258 for each loop to avoid checking for\n       output space.\n  */\n module.exports = function inflate_fast(strm, start) {\n   var state;\n   var _in;                    /* local strm.input */\n   var last;                   /* have enough input while in < last */\n   var _out;                   /* local strm.output */\n   var beg;                    /* inflate()'s initial strm.output */\n   var end;                    /* while out < end, enough space available */\n //#ifdef INFLATE_STRICT\n   var dmax;                   /* maximum distance from zlib header */\n //#endif\n   var wsize;                  /* window size or zero if not using window */\n   var whave;                  /* valid bytes in the window */\n   var wnext;                  /* window write index */\n   // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n   var s_window;               /* allocated sliding window, if wsize != 0 */\n   var hold;                   /* local strm.hold */\n   var bits;                   /* local strm.bits */\n   var lcode;                  /* local strm.lencode */\n   var dcode;                  /* local strm.distcode */\n   var lmask;                  /* mask for first level of length codes */\n   var dmask;                  /* mask for first level of distance codes */\n   var here;                   /* retrieved table entry */\n   var op;                     /* code bits, operation, extra bits, or */\n                               /*  window position, window bytes to copy */\n   var len;                    /* match length, unused bytes */\n   var dist;                   /* match distance */\n   var from;                   /* where to copy match from */\n   var from_source;\n\n\n   var input, output; // JS specific, because we have no pointers\n\n   /* copy state to local variables */\n   state = strm.state;\n   //here = state.here;\n   _in = strm.next_in;\n   input = strm.input;\n   last = _in + (strm.avail_in - 5);\n   _out = strm.next_out;\n   output = strm.output;\n   beg = _out - (start - strm.avail_out);\n   end = _out + (strm.avail_out - 257);\n //#ifdef INFLATE_STRICT\n   dmax = state.dmax;\n //#endif\n   wsize = state.wsize;\n   whave = state.whave;\n   wnext = state.wnext;\n   s_window = state.window;\n   hold = state.hold;\n   bits = state.bits;\n   lcode = state.lencode;\n   dcode = state.distcode;\n   lmask = (1 << state.lenbits) - 1;\n   dmask = (1 << state.distbits) - 1;\n\n\n   /* decode literals and length/distances until end-of-block or not enough\n      input data or output space */\n\n   top:\n   do {\n     if (bits < 15) {\n       hold += input[_in++] << bits;\n       bits += 8;\n       hold += input[_in++] << bits;\n       bits += 8;\n     }\n\n     here = lcode[hold & lmask];\n\n     dolen:\n     for (;;) { // Goto emulation\n       op = here >>> 24/*here.bits*/;\n       hold >>>= op;\n       bits -= op;\n       op = (here >>> 16) & 0xff/*here.op*/;\n       if (op === 0) {                          /* literal */\n         //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n         //        \"inflate:         literal '%c'\\n\" :\n         //        \"inflate:         literal 0x%02x\\n\", here.val));\n         output[_out++] = here & 0xffff/*here.val*/;\n       }\n       else if (op & 16) {                     /* length base */\n         len = here & 0xffff/*here.val*/;\n         op &= 15;                           /* number of extra bits */\n         if (op) {\n           if (bits < op) {\n             hold += input[_in++] << bits;\n             bits += 8;\n           }\n           len += hold & ((1 << op) - 1);\n           hold >>>= op;\n           bits -= op;\n         }\n         //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n         if (bits < 15) {\n           hold += input[_in++] << bits;\n           bits += 8;\n           hold += input[_in++] << bits;\n           bits += 8;\n         }\n         here = dcode[hold & dmask];\n\n         dodist:\n         for (;;) { // goto emulation\n           op = here >>> 24/*here.bits*/;\n           hold >>>= op;\n           bits -= op;\n           op = (here >>> 16) & 0xff/*here.op*/;\n\n           if (op & 16) {                      /* distance base */\n             dist = here & 0xffff/*here.val*/;\n             op &= 15;                       /* number of extra bits */\n             if (bits < op) {\n               hold += input[_in++] << bits;\n               bits += 8;\n               if (bits < op) {\n                 hold += input[_in++] << bits;\n                 bits += 8;\n               }\n             }\n             dist += hold & ((1 << op) - 1);\n //#ifdef INFLATE_STRICT\n             if (dist > dmax) {\n               strm.msg = 'invalid distance too far back';\n               state.mode = BAD;\n               break top;\n             }\n //#endif\n             hold >>>= op;\n             bits -= op;\n             //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n             op = _out - beg;                /* max distance in output */\n             if (dist > op) {                /* see if copy from window */\n               op = dist - op;               /* distance back in window */\n               if (op > whave) {\n                 if (state.sane) {\n                   strm.msg = 'invalid distance too far back';\n                   state.mode = BAD;\n                   break top;\n                 }\n\n // (!) This block is disabled in zlib defaults,\n // don't enable it for binary compatibility\n //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n //                if (len <= op - whave) {\n //                  do {\n //                    output[_out++] = 0;\n //                  } while (--len);\n //                  continue top;\n //                }\n //                len -= op - whave;\n //                do {\n //                  output[_out++] = 0;\n //                } while (--op > whave);\n //                if (op === 0) {\n //                  from = _out - dist;\n //                  do {\n //                    output[_out++] = output[from++];\n //                  } while (--len);\n //                  continue top;\n //                }\n //#endif\n               }\n               from = 0; // window index\n               from_source = s_window;\n               if (wnext === 0) {           /* very common case */\n                 from += wsize - op;\n                 if (op < len) {         /* some from window */\n                   len -= op;\n                   do {\n                     output[_out++] = s_window[from++];\n                   } while (--op);\n                   from = _out - dist;  /* rest from output */\n                   from_source = output;\n                 }\n               }\n               else if (wnext < op) {      /* wrap around window */\n                 from += wsize + wnext - op;\n                 op -= wnext;\n                 if (op < len) {         /* some from end of window */\n                   len -= op;\n                   do {\n                     output[_out++] = s_window[from++];\n                   } while (--op);\n                   from = 0;\n                   if (wnext < len) {  /* some from start of window */\n                     op = wnext;\n                     len -= op;\n                     do {\n                       output[_out++] = s_window[from++];\n                     } while (--op);\n                     from = _out - dist;      /* rest from output */\n                     from_source = output;\n                   }\n                 }\n               }\n               else {                      /* contiguous in window */\n                 from += wnext - op;\n                 if (op < len) {         /* some from window */\n                   len -= op;\n                   do {\n                     output[_out++] = s_window[from++];\n                   } while (--op);\n                   from = _out - dist;  /* rest from output */\n                   from_source = output;\n                 }\n               }\n               while (len > 2) {\n                 output[_out++] = from_source[from++];\n                 output[_out++] = from_source[from++];\n                 output[_out++] = from_source[from++];\n                 len -= 3;\n               }\n               if (len) {\n                 output[_out++] = from_source[from++];\n                 if (len > 1) {\n                   output[_out++] = from_source[from++];\n                 }\n               }\n             }\n             else {\n               from = _out - dist;          /* copy direct from output */\n               do {                        /* minimum length is three */\n                 output[_out++] = output[from++];\n                 output[_out++] = output[from++];\n                 output[_out++] = output[from++];\n                 len -= 3;\n               } while (len > 2);\n               if (len) {\n                 output[_out++] = output[from++];\n                 if (len > 1) {\n                   output[_out++] = output[from++];\n                 }\n               }\n             }\n           }\n           else if ((op & 64) === 0) {          /* 2nd level distance code */\n             here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n             continue dodist;\n           }\n           else {\n             strm.msg = 'invalid distance code';\n             state.mode = BAD;\n             break top;\n           }\n\n           break; // need to emulate goto via \"continue\"\n         }\n       }\n       else if ((op & 64) === 0) {              /* 2nd level length code */\n         here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n         continue dolen;\n       }\n       else if (op & 32) {                     /* end-of-block */\n         //Tracevv((stderr, \"inflate:         end of block\\n\"));\n         state.mode = TYPE;\n         break top;\n       }\n       else {\n         strm.msg = 'invalid literal/length code';\n         state.mode = BAD;\n         break top;\n       }\n\n       break; // need to emulate goto via \"continue\"\n     }\n   } while (_in < last && _out < end);\n\n   /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n   len = bits >> 3;\n   _in -= len;\n   bits -= len << 3;\n   hold &= (1 << bits) - 1;\n\n   /* update state and return */\n   strm.next_in = _in;\n   strm.next_out = _out;\n   strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n   strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n   state.hold = hold;\n   state.bits = bits;\n   return;\n };\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n\n\n}, {});\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}