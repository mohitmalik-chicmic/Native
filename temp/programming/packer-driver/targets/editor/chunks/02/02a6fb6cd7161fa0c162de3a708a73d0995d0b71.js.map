{"version":3,"sources":["file:///Users/chicmic/Documents/InhouseCOCOS/ZipExtractor/node_modules/pako/lib/zlib/trees.js"],"names":["_cjsLoader","_req","__cjsMetaURL","url","define","exports","require","module","__filename","__dirname","utils","Z_FIXED","Z_BINARY","Z_TEXT","Z_UNKNOWN","zero","buf","len","length","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH","MAX_MATCH","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","Array","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","bi_flush","gen_bitlen","desc","stree","extra","base","h","n","m","bits","xbits","f","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","bi_windup","copy_block","header","arraySet","window","smaller","depth","_n2","_m2","pqdownheap","k","v","j","heap_len","compress_block","ltree","dtree","lc","lx","d_buf","l_buf","build_tree","node","scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","rank","detect_data_type","black_mask","static_init_done","_tr_init","_tr_stored_block","stored_len","last","_tr_align","_tr_flush_block","opt_lenb","static_lenb","level","strm","data_type","strategy","_tr_tally","lit_bufsize","_cjsExports","__tr_init","__tr_stored_block","__tr_flush_block","__tr_tally","__tr_align"],"mappings":"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","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nimport { __cjsMetaURL as _req} from '../utils/common';\nlet _cjsExports;\nlet __tr_init;\nlet __tr_stored_block;\nlet __tr_flush_block;\nlet __tr_tally;\nlet __tr_align;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n 'use strict';\n\n // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n //\n // This software is provided 'as-is', without any express or implied\n // warranty. In no event will the authors be held liable for any damages\n // arising from the use of this software.\n //\n // Permission is granted to anyone to use this software for any purpose,\n // including commercial applications, and to alter it and redistribute it\n // freely, subject to the following restrictions:\n //\n // 1. The origin of this software must not be misrepresented; you must not\n //   claim that you wrote the original software. If you use this software\n //   in a product, an acknowledgment in the product documentation would be\n //   appreciated but is not required.\n // 2. Altered source versions must be plainly marked as such, and must not be\n //   misrepresented as being the original software.\n // 3. This notice may not be removed or altered from any source distribution.\n\n /* eslint-disable space-unary-ops */\n\n var utils = require('../utils/common');\n\n /* Public constants ==========================================================*/\n /* ===========================================================================*/\n\n\n //var Z_FILTERED          = 1;\n //var Z_HUFFMAN_ONLY      = 2;\n //var Z_RLE               = 3;\n var Z_FIXED               = 4;\n //var Z_DEFAULT_STRATEGY  = 0;\n\n /* Possible values of the data_type field (though see inflate()) */\n var Z_BINARY              = 0;\n var Z_TEXT                = 1;\n //var Z_ASCII             = 1; // = Z_TEXT\n var Z_UNKNOWN             = 2;\n\n /*============================================================================*/\n\n\n function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n // From zutil.h\n\n var STORED_BLOCK = 0;\n var STATIC_TREES = 1;\n var DYN_TREES    = 2;\n /* The three kinds of block type */\n\n var MIN_MATCH    = 3;\n var MAX_MATCH    = 258;\n /* The minimum and maximum match lengths */\n\n // From deflate.h\n /* ===========================================================================\n  * Internal compression state.\n  */\n\n var LENGTH_CODES  = 29;\n /* number of length codes, not counting the special END_BLOCK code */\n\n var LITERALS      = 256;\n /* number of literal bytes 0..255 */\n\n var L_CODES       = LITERALS + 1 + LENGTH_CODES;\n /* number of Literal or Length codes, including the END_BLOCK code */\n\n var D_CODES       = 30;\n /* number of distance codes */\n\n var BL_CODES      = 19;\n /* number of codes used to transfer the bit lengths */\n\n var HEAP_SIZE     = 2 * L_CODES + 1;\n /* maximum heap size */\n\n var MAX_BITS      = 15;\n /* All codes must not exceed MAX_BITS bits */\n\n var Buf_size      = 16;\n /* size of bit buffer in bi_buf */\n\n\n /* ===========================================================================\n  * Constants\n  */\n\n var MAX_BL_BITS = 7;\n /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n var END_BLOCK   = 256;\n /* end of block literal code */\n\n var REP_3_6     = 16;\n /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n var REPZ_3_10   = 17;\n /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n var REPZ_11_138 = 18;\n /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n /* eslint-disable comma-spacing,array-bracket-spacing */\n var extra_lbits =   /* extra bits for each length code */\n   [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\n var extra_dbits =   /* extra bits for each distance code */\n   [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\n var extra_blbits =  /* extra bits for each bit length code */\n   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\n var bl_order =\n   [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n /* eslint-enable comma-spacing,array-bracket-spacing */\n\n /* The lengths of the bit length codes are sent in order of decreasing\n  * probability, to avoid transmitting the lengths for unused bit length codes.\n  */\n\n /* ===========================================================================\n  * Local data. These are initialized only once.\n  */\n\n // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n var DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n var static_ltree  = new Array((L_CODES + 2) * 2);\n zero(static_ltree);\n /* The static literal tree. Since the bit lengths are imposed, there is no\n  * need for the L_CODES extra codes used during heap construction. However\n  * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n  * below).\n  */\n\n var static_dtree  = new Array(D_CODES * 2);\n zero(static_dtree);\n /* The static distance tree. (Actually a trivial tree since all codes use\n  * 5 bits.)\n  */\n\n var _dist_code    = new Array(DIST_CODE_LEN);\n zero(_dist_code);\n /* Distance codes. The first 256 values correspond to the distances\n  * 3 .. 258, the last 256 values correspond to the top 8 bits of\n  * the 15 bit distances.\n  */\n\n var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\n zero(_length_code);\n /* length code for each normalized match length (0 == MIN_MATCH) */\n\n var base_length   = new Array(LENGTH_CODES);\n zero(base_length);\n /* First normalized length for each code (0 = MIN_MATCH) */\n\n var base_dist     = new Array(D_CODES);\n zero(base_dist);\n /* First normalized distance for each code (0 = distance of 1) */\n\n\n function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n   this.static_tree  = static_tree;  /* static tree or NULL */\n   this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n   this.extra_base   = extra_base;   /* base index for extra_bits */\n   this.elems        = elems;        /* max number of elements in the tree */\n   this.max_length   = max_length;   /* max bit length for the codes */\n\n   // show if `static_tree` has data or dummy - needed for monomorphic objects\n   this.has_stree    = static_tree && static_tree.length;\n }\n\n\n var static_l_desc;\n var static_d_desc;\n var static_bl_desc;\n\n\n function TreeDesc(dyn_tree, stat_desc) {\n   this.dyn_tree = dyn_tree;     /* the dynamic tree */\n   this.max_code = 0;            /* largest code with non zero frequency */\n   this.stat_desc = stat_desc;   /* the corresponding static tree */\n }\n\n\n\n function d_code(dist) {\n   return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n }\n\n\n /* ===========================================================================\n  * Output a short LSB first on the stream.\n  * IN assertion: there is enough room in pendingBuf.\n  */\n function put_short(s, w) {\n //    put_byte(s, (uch)((w) & 0xff));\n //    put_byte(s, (uch)((ush)(w) >> 8));\n   s.pending_buf[s.pending++] = (w) & 0xff;\n   s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n }\n\n\n /* ===========================================================================\n  * Send a value on a given number of bits.\n  * IN assertion: length <= 16 and value fits in length bits.\n  */\n function send_bits(s, value, length) {\n   if (s.bi_valid > (Buf_size - length)) {\n     s.bi_buf |= (value << s.bi_valid) & 0xffff;\n     put_short(s, s.bi_buf);\n     s.bi_buf = value >> (Buf_size - s.bi_valid);\n     s.bi_valid += length - Buf_size;\n   } else {\n     s.bi_buf |= (value << s.bi_valid) & 0xffff;\n     s.bi_valid += length;\n   }\n }\n\n\n function send_code(s, c, tree) {\n   send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n }\n\n\n /* ===========================================================================\n  * Reverse the first len bits of a code, using straightforward code (a faster\n  * method would use a table)\n  * IN assertion: 1 <= len <= 15\n  */\n function bi_reverse(code, len) {\n   var res = 0;\n   do {\n     res |= code & 1;\n     code >>>= 1;\n     res <<= 1;\n   } while (--len > 0);\n   return res >>> 1;\n }\n\n\n /* ===========================================================================\n  * Flush the bit buffer, keeping at most 7 bits in it.\n  */\n function bi_flush(s) {\n   if (s.bi_valid === 16) {\n     put_short(s, s.bi_buf);\n     s.bi_buf = 0;\n     s.bi_valid = 0;\n\n   } else if (s.bi_valid >= 8) {\n     s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n     s.bi_buf >>= 8;\n     s.bi_valid -= 8;\n   }\n }\n\n\n /* ===========================================================================\n  * Compute the optimal bit lengths for a tree and update the total bit length\n  * for the current block.\n  * IN assertion: the fields freq and dad are set, heap[heap_max] and\n  *    above are the tree nodes sorted by increasing frequency.\n  * OUT assertions: the field len is set to the optimal bit length, the\n  *     array bl_count contains the frequencies for each bit length.\n  *     The length opt_len is updated; static_len is also updated if stree is\n  *     not null.\n  */\n function gen_bitlen(s, desc)\n //    deflate_state *s;\n //    tree_desc *desc;    /* the tree descriptor */\n {\n   var tree            = desc.dyn_tree;\n   var max_code        = desc.max_code;\n   var stree           = desc.stat_desc.static_tree;\n   var has_stree       = desc.stat_desc.has_stree;\n   var extra           = desc.stat_desc.extra_bits;\n   var base            = desc.stat_desc.extra_base;\n   var max_length      = desc.stat_desc.max_length;\n   var h;              /* heap index */\n   var n, m;           /* iterate over the tree elements */\n   var bits;           /* bit length */\n   var xbits;          /* extra bits */\n   var f;              /* frequency */\n   var overflow = 0;   /* number of elements with bit length too large */\n\n   for (bits = 0; bits <= MAX_BITS; bits++) {\n     s.bl_count[bits] = 0;\n   }\n\n   /* In a first pass, compute the optimal bit lengths (which may\n    * overflow in the case of the bit length tree).\n    */\n   tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n   for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n     n = s.heap[h];\n     bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n     if (bits > max_length) {\n       bits = max_length;\n       overflow++;\n     }\n     tree[n * 2 + 1]/*.Len*/ = bits;\n     /* We overwrite tree[n].Dad which is no longer needed */\n\n     if (n > max_code) { continue; } /* not a leaf node */\n\n     s.bl_count[bits]++;\n     xbits = 0;\n     if (n >= base) {\n       xbits = extra[n - base];\n     }\n     f = tree[n * 2]/*.Freq*/;\n     s.opt_len += f * (bits + xbits);\n     if (has_stree) {\n       s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n     }\n   }\n   if (overflow === 0) { return; }\n\n   // Trace((stderr,\"\\nbit length overflow\\n\"));\n   /* This happens for example on obj2 and pic of the Calgary corpus */\n\n   /* Find the first bit length which could increase: */\n   do {\n     bits = max_length - 1;\n     while (s.bl_count[bits] === 0) { bits--; }\n     s.bl_count[bits]--;      /* move one leaf down the tree */\n     s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n     s.bl_count[max_length]--;\n     /* The brother of the overflow item also moves one step up,\n      * but this does not affect bl_count[max_length]\n      */\n     overflow -= 2;\n   } while (overflow > 0);\n\n   /* Now recompute all bit lengths, scanning in increasing frequency.\n    * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n    * lengths instead of fixing only the wrong ones. This idea is taken\n    * from 'ar' written by Haruhiko Okumura.)\n    */\n   for (bits = max_length; bits !== 0; bits--) {\n     n = s.bl_count[bits];\n     while (n !== 0) {\n       m = s.heap[--h];\n       if (m > max_code) { continue; }\n       if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n         // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n         s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n         tree[m * 2 + 1]/*.Len*/ = bits;\n       }\n       n--;\n     }\n   }\n }\n\n\n /* ===========================================================================\n  * Generate the codes for a given tree and bit counts (which need not be\n  * optimal).\n  * IN assertion: the array bl_count contains the bit length statistics for\n  * the given tree and the field len is set for all tree elements.\n  * OUT assertion: the field code is set for all tree elements of non\n  *     zero code length.\n  */\n function gen_codes(tree, max_code, bl_count)\n //    ct_data *tree;             /* the tree to decorate */\n //    int max_code;              /* largest code with non zero frequency */\n //    ushf *bl_count;            /* number of codes at each bit length */\n {\n   var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n   var code = 0;              /* running code value */\n   var bits;                  /* bit index */\n   var n;                     /* code index */\n\n   /* The distribution counts are first used to generate the code values\n    * without bit reversal.\n    */\n   for (bits = 1; bits <= MAX_BITS; bits++) {\n     next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n   }\n   /* Check that the bit counts in bl_count are consistent. The last code\n    * must be all ones.\n    */\n   //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n   //        \"inconsistent bit counts\");\n   //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n   for (n = 0;  n <= max_code; n++) {\n     var len = tree[n * 2 + 1]/*.Len*/;\n     if (len === 0) { continue; }\n     /* Now reverse the bits */\n     tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n     //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n     //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n   }\n }\n\n\n /* ===========================================================================\n  * Initialize the various 'constant' tables.\n  */\n function tr_static_init() {\n   var n;        /* iterates over tree elements */\n   var bits;     /* bit counter */\n   var length;   /* length value */\n   var code;     /* code value */\n   var dist;     /* distance index */\n   var bl_count = new Array(MAX_BITS + 1);\n   /* number of codes at each bit length for an optimal tree */\n\n   // do check in _tr_init()\n   //if (static_init_done) return;\n\n   /* For some embedded targets, global variables are not initialized: */\n /*#ifdef NO_INIT_GLOBAL_POINTERS\n   static_l_desc.static_tree = static_ltree;\n   static_l_desc.extra_bits = extra_lbits;\n   static_d_desc.static_tree = static_dtree;\n   static_d_desc.extra_bits = extra_dbits;\n   static_bl_desc.extra_bits = extra_blbits;\n #endif*/\n\n   /* Initialize the mapping length (0..255) -> length code (0..28) */\n   length = 0;\n   for (code = 0; code < LENGTH_CODES - 1; code++) {\n     base_length[code] = length;\n     for (n = 0; n < (1 << extra_lbits[code]); n++) {\n       _length_code[length++] = code;\n     }\n   }\n   //Assert (length == 256, \"tr_static_init: length != 256\");\n   /* Note that the length 255 (match length 258) can be represented\n    * in two different ways: code 284 + 5 bits or code 285, so we\n    * overwrite length_code[255] to use the best encoding:\n    */\n   _length_code[length - 1] = code;\n\n   /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n   dist = 0;\n   for (code = 0; code < 16; code++) {\n     base_dist[code] = dist;\n     for (n = 0; n < (1 << extra_dbits[code]); n++) {\n       _dist_code[dist++] = code;\n     }\n   }\n   //Assert (dist == 256, \"tr_static_init: dist != 256\");\n   dist >>= 7; /* from now on, all distances are divided by 128 */\n   for (; code < D_CODES; code++) {\n     base_dist[code] = dist << 7;\n     for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n       _dist_code[256 + dist++] = code;\n     }\n   }\n   //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n   /* Construct the codes of the static literal tree */\n   for (bits = 0; bits <= MAX_BITS; bits++) {\n     bl_count[bits] = 0;\n   }\n\n   n = 0;\n   while (n <= 143) {\n     static_ltree[n * 2 + 1]/*.Len*/ = 8;\n     n++;\n     bl_count[8]++;\n   }\n   while (n <= 255) {\n     static_ltree[n * 2 + 1]/*.Len*/ = 9;\n     n++;\n     bl_count[9]++;\n   }\n   while (n <= 279) {\n     static_ltree[n * 2 + 1]/*.Len*/ = 7;\n     n++;\n     bl_count[7]++;\n   }\n   while (n <= 287) {\n     static_ltree[n * 2 + 1]/*.Len*/ = 8;\n     n++;\n     bl_count[8]++;\n   }\n   /* Codes 286 and 287 do not exist, but we must include them in the\n    * tree construction to get a canonical Huffman tree (longest code\n    * all ones)\n    */\n   gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n   /* The static distance tree is trivial: */\n   for (n = 0; n < D_CODES; n++) {\n     static_dtree[n * 2 + 1]/*.Len*/ = 5;\n     static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n   }\n\n   // Now data ready and we can init static trees\n   static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n   static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n   static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n   //static_init_done = true;\n }\n\n\n /* ===========================================================================\n  * Initialize a new block.\n  */\n function init_block(s) {\n   var n; /* iterates over tree elements */\n\n   /* Initialize the trees. */\n   for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n   for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n   for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n   s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n   s.opt_len = s.static_len = 0;\n   s.last_lit = s.matches = 0;\n }\n\n\n /* ===========================================================================\n  * Flush the bit buffer and align the output on a byte boundary\n  */\n function bi_windup(s)\n {\n   if (s.bi_valid > 8) {\n     put_short(s, s.bi_buf);\n   } else if (s.bi_valid > 0) {\n     //put_byte(s, (Byte)s->bi_buf);\n     s.pending_buf[s.pending++] = s.bi_buf;\n   }\n   s.bi_buf = 0;\n   s.bi_valid = 0;\n }\n\n /* ===========================================================================\n  * Copy a stored block, storing first the length and its\n  * one's complement if requested.\n  */\n function copy_block(s, buf, len, header)\n //DeflateState *s;\n //charf    *buf;    /* the input data */\n //unsigned len;     /* its length */\n //int      header;  /* true if block header must be written */\n {\n   bi_windup(s);        /* align on byte boundary */\n\n   if (header) {\n     put_short(s, len);\n     put_short(s, ~len);\n   }\n //  while (len--) {\n //    put_byte(s, *buf++);\n //  }\n   utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n   s.pending += len;\n }\n\n /* ===========================================================================\n  * Compares to subtrees, using the tree depth as tie breaker when\n  * the subtrees have equal frequency. This minimizes the worst case length.\n  */\n function smaller(tree, n, m, depth) {\n   var _n2 = n * 2;\n   var _m2 = m * 2;\n   return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n          (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n }\n\n /* ===========================================================================\n  * Restore the heap property by moving down the tree starting at node k,\n  * exchanging a node with the smallest of its two sons if necessary, stopping\n  * when the heap property is re-established (each father smaller than its\n  * two sons).\n  */\n function pqdownheap(s, tree, k)\n //    deflate_state *s;\n //    ct_data *tree;  /* the tree to restore */\n //    int k;               /* node to move down */\n {\n   var v = s.heap[k];\n   var j = k << 1;  /* left son of k */\n   while (j <= s.heap_len) {\n     /* Set j to the smallest of the two sons: */\n     if (j < s.heap_len &&\n       smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n       j++;\n     }\n     /* Exit if v is smaller than both sons */\n     if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n     /* Exchange v with the smallest son */\n     s.heap[k] = s.heap[j];\n     k = j;\n\n     /* And continue down the tree, setting j to the left son of k */\n     j <<= 1;\n   }\n   s.heap[k] = v;\n }\n\n\n // inlined manually\n // var SMALLEST = 1;\n\n /* ===========================================================================\n  * Send the block data compressed using the given Huffman trees\n  */\n function compress_block(s, ltree, dtree)\n //    deflate_state *s;\n //    const ct_data *ltree; /* literal tree */\n //    const ct_data *dtree; /* distance tree */\n {\n   var dist;           /* distance of matched string */\n   var lc;             /* match length or unmatched char (if dist == 0) */\n   var lx = 0;         /* running index in l_buf */\n   var code;           /* the code to send */\n   var extra;          /* number of extra bits to send */\n\n   if (s.last_lit !== 0) {\n     do {\n       dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n       lc = s.pending_buf[s.l_buf + lx];\n       lx++;\n\n       if (dist === 0) {\n         send_code(s, lc, ltree); /* send a literal byte */\n         //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n       } else {\n         /* Here, lc is the match length - MIN_MATCH */\n         code = _length_code[lc];\n         send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n         extra = extra_lbits[code];\n         if (extra !== 0) {\n           lc -= base_length[code];\n           send_bits(s, lc, extra);       /* send the extra length bits */\n         }\n         dist--; /* dist is now the match distance - 1 */\n         code = d_code(dist);\n         //Assert (code < D_CODES, \"bad d_code\");\n\n         send_code(s, code, dtree);       /* send the distance code */\n         extra = extra_dbits[code];\n         if (extra !== 0) {\n           dist -= base_dist[code];\n           send_bits(s, dist, extra);   /* send the extra distance bits */\n         }\n       } /* literal or match pair ? */\n\n       /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n       //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n       //       \"pendingBuf overflow\");\n\n     } while (lx < s.last_lit);\n   }\n\n   send_code(s, END_BLOCK, ltree);\n }\n\n\n /* ===========================================================================\n  * Construct one Huffman tree and assigns the code bit strings and lengths.\n  * Update the total bit length for the current block.\n  * IN assertion: the field freq is set for all tree elements.\n  * OUT assertions: the fields len and code are set to the optimal bit length\n  *     and corresponding code. The length opt_len is updated; static_len is\n  *     also updated if stree is not null. The field max_code is set.\n  */\n function build_tree(s, desc)\n //    deflate_state *s;\n //    tree_desc *desc; /* the tree descriptor */\n {\n   var tree     = desc.dyn_tree;\n   var stree    = desc.stat_desc.static_tree;\n   var has_stree = desc.stat_desc.has_stree;\n   var elems    = desc.stat_desc.elems;\n   var n, m;          /* iterate over heap elements */\n   var max_code = -1; /* largest code with non zero frequency */\n   var node;          /* new node being created */\n\n   /* Construct the initial heap, with least frequent element in\n    * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n    * heap[0] is not used.\n    */\n   s.heap_len = 0;\n   s.heap_max = HEAP_SIZE;\n\n   for (n = 0; n < elems; n++) {\n     if (tree[n * 2]/*.Freq*/ !== 0) {\n       s.heap[++s.heap_len] = max_code = n;\n       s.depth[n] = 0;\n\n     } else {\n       tree[n * 2 + 1]/*.Len*/ = 0;\n     }\n   }\n\n   /* The pkzip format requires that at least one distance code exists,\n    * and that at least one bit should be sent even if there is only one\n    * possible code. So to avoid special checks later on we force at least\n    * two codes of non zero frequency.\n    */\n   while (s.heap_len < 2) {\n     node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n     tree[node * 2]/*.Freq*/ = 1;\n     s.depth[node] = 0;\n     s.opt_len--;\n\n     if (has_stree) {\n       s.static_len -= stree[node * 2 + 1]/*.Len*/;\n     }\n     /* node is 0 or 1 so it does not have extra bits */\n   }\n   desc.max_code = max_code;\n\n   /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n    * establish sub-heaps of increasing lengths:\n    */\n   for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n   /* Construct the Huffman tree by repeatedly combining the least two\n    * frequent nodes.\n    */\n   node = elems;              /* next internal node of the tree */\n   do {\n     //pqremove(s, tree, n);  /* n = node of least frequency */\n     /*** pqremove ***/\n     n = s.heap[1/*SMALLEST*/];\n     s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n     pqdownheap(s, tree, 1/*SMALLEST*/);\n     /***/\n\n     m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n     s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n     s.heap[--s.heap_max] = m;\n\n     /* Create a new node father of n and m */\n     tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n     s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n     tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n     /* and insert the new node in the heap */\n     s.heap[1/*SMALLEST*/] = node++;\n     pqdownheap(s, tree, 1/*SMALLEST*/);\n\n   } while (s.heap_len >= 2);\n\n   s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n   /* At this point, the fields freq and dad are set. We can now\n    * generate the bit lengths.\n    */\n   gen_bitlen(s, desc);\n\n   /* The field len is now set, we can generate the bit codes */\n   gen_codes(tree, max_code, s.bl_count);\n }\n\n\n /* ===========================================================================\n  * Scan a literal or distance tree to determine the frequencies of the codes\n  * in the bit length tree.\n  */\n function scan_tree(s, tree, max_code)\n //    deflate_state *s;\n //    ct_data *tree;   /* the tree to be scanned */\n //    int max_code;    /* and its largest code of non zero frequency */\n {\n   var n;                     /* iterates over all tree elements */\n   var prevlen = -1;          /* last emitted length */\n   var curlen;                /* length of current code */\n\n   var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n   var count = 0;             /* repeat count of the current code */\n   var max_count = 7;         /* max repeat count */\n   var min_count = 4;         /* min repeat count */\n\n   if (nextlen === 0) {\n     max_count = 138;\n     min_count = 3;\n   }\n   tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n   for (n = 0; n <= max_code; n++) {\n     curlen = nextlen;\n     nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n     if (++count < max_count && curlen === nextlen) {\n       continue;\n\n     } else if (count < min_count) {\n       s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n     } else if (curlen !== 0) {\n\n       if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n       s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n     } else if (count <= 10) {\n       s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n     } else {\n       s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n     }\n\n     count = 0;\n     prevlen = curlen;\n\n     if (nextlen === 0) {\n       max_count = 138;\n       min_count = 3;\n\n     } else if (curlen === nextlen) {\n       max_count = 6;\n       min_count = 3;\n\n     } else {\n       max_count = 7;\n       min_count = 4;\n     }\n   }\n }\n\n\n /* ===========================================================================\n  * Send a literal or distance tree in compressed form, using the codes in\n  * bl_tree.\n  */\n function send_tree(s, tree, max_code)\n //    deflate_state *s;\n //    ct_data *tree; /* the tree to be scanned */\n //    int max_code;       /* and its largest code of non zero frequency */\n {\n   var n;                     /* iterates over all tree elements */\n   var prevlen = -1;          /* last emitted length */\n   var curlen;                /* length of current code */\n\n   var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n   var count = 0;             /* repeat count of the current code */\n   var max_count = 7;         /* max repeat count */\n   var min_count = 4;         /* min repeat count */\n\n   /* tree[max_code+1].Len = -1; */  /* guard already set */\n   if (nextlen === 0) {\n     max_count = 138;\n     min_count = 3;\n   }\n\n   for (n = 0; n <= max_code; n++) {\n     curlen = nextlen;\n     nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n     if (++count < max_count && curlen === nextlen) {\n       continue;\n\n     } else if (count < min_count) {\n       do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n     } else if (curlen !== 0) {\n       if (curlen !== prevlen) {\n         send_code(s, curlen, s.bl_tree);\n         count--;\n       }\n       //Assert(count >= 3 && count <= 6, \" 3_6?\");\n       send_code(s, REP_3_6, s.bl_tree);\n       send_bits(s, count - 3, 2);\n\n     } else if (count <= 10) {\n       send_code(s, REPZ_3_10, s.bl_tree);\n       send_bits(s, count - 3, 3);\n\n     } else {\n       send_code(s, REPZ_11_138, s.bl_tree);\n       send_bits(s, count - 11, 7);\n     }\n\n     count = 0;\n     prevlen = curlen;\n     if (nextlen === 0) {\n       max_count = 138;\n       min_count = 3;\n\n     } else if (curlen === nextlen) {\n       max_count = 6;\n       min_count = 3;\n\n     } else {\n       max_count = 7;\n       min_count = 4;\n     }\n   }\n }\n\n\n /* ===========================================================================\n  * Construct the Huffman tree for the bit lengths and return the index in\n  * bl_order of the last bit length code to send.\n  */\n function build_bl_tree(s) {\n   var max_blindex;  /* index of last bit length code of non zero freq */\n\n   /* Determine the bit length frequencies for literal and distance trees */\n   scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n   scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n   /* Build the bit length tree: */\n   build_tree(s, s.bl_desc);\n   /* opt_len now includes the length of the tree representations, except\n    * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n    */\n\n   /* Determine the number of bit length codes to send. The pkzip format\n    * requires that at least 4 bit length codes be sent. (appnote.txt says\n    * 3 but the actual value used is 4.)\n    */\n   for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n     if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n       break;\n     }\n   }\n   /* Update opt_len to include the bit length tree and counts */\n   s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n   //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n   //        s->opt_len, s->static_len));\n\n   return max_blindex;\n }\n\n\n /* ===========================================================================\n  * Send the header for a block using dynamic Huffman trees: the counts, the\n  * lengths of the bit length codes, the literal tree and the distance tree.\n  * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n  */\n function send_all_trees(s, lcodes, dcodes, blcodes)\n //    deflate_state *s;\n //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n {\n   var rank;                    /* index in bl_order */\n\n   //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n   //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n   //        \"too many codes\");\n   //Tracev((stderr, \"\\nbl counts: \"));\n   send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n   send_bits(s, dcodes - 1,   5);\n   send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n   for (rank = 0; rank < blcodes; rank++) {\n     //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n     send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n   }\n   //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n   send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n   //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n   send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n   //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n }\n\n\n /* ===========================================================================\n  * Check if the data type is TEXT or BINARY, using the following algorithm:\n  * - TEXT if the two conditions below are satisfied:\n  *    a) There are no non-portable control characters belonging to the\n  *       \"black list\" (0..6, 14..25, 28..31).\n  *    b) There is at least one printable character belonging to the\n  *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n  * - BINARY otherwise.\n  * - The following partially-portable control characters form a\n  *   \"gray list\" that is ignored in this detection algorithm:\n  *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n  * IN assertion: the fields Freq of dyn_ltree are set.\n  */\n function detect_data_type(s) {\n   /* black_mask is the bit mask of black-listed bytes\n    * set bits 0..6, 14..25, and 28..31\n    * 0xf3ffc07f = binary 11110011111111111100000001111111\n    */\n   var black_mask = 0xf3ffc07f;\n   var n;\n\n   /* Check for non-textual (\"black-listed\") bytes. */\n   for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n     if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n       return Z_BINARY;\n     }\n   }\n\n   /* Check for textual (\"white-listed\") bytes. */\n   if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n       s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n     return Z_TEXT;\n   }\n   for (n = 32; n < LITERALS; n++) {\n     if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n       return Z_TEXT;\n     }\n   }\n\n   /* There are no \"black-listed\" or \"white-listed\" bytes:\n    * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n    */\n   return Z_BINARY;\n }\n\n\n var static_init_done = false;\n\n /* ===========================================================================\n  * Initialize the tree data structures for a new zlib stream.\n  */\n function _tr_init(s)\n {\n\n   if (!static_init_done) {\n     tr_static_init();\n     static_init_done = true;\n   }\n\n   s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n   s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n   s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n   s.bi_buf = 0;\n   s.bi_valid = 0;\n\n   /* Initialize the first block of the first file: */\n   init_block(s);\n }\n\n\n /* ===========================================================================\n  * Send a stored block\n  */\n function _tr_stored_block(s, buf, stored_len, last)\n //DeflateState *s;\n //charf *buf;       /* input block */\n //ulg stored_len;   /* length of input block */\n //int last;         /* one if this is the last block for a file */\n {\n   send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n   copy_block(s, buf, stored_len, true); /* with header */\n }\n\n\n /* ===========================================================================\n  * Send one empty static block to give enough lookahead for inflate.\n  * This takes 10 bits, of which 7 may remain in the bit buffer.\n  */\n function _tr_align(s) {\n   send_bits(s, STATIC_TREES << 1, 3);\n   send_code(s, END_BLOCK, static_ltree);\n   bi_flush(s);\n }\n\n\n /* ===========================================================================\n  * Determine the best encoding for the current block: dynamic trees, static\n  * trees or store, and output the encoded block to the zip file.\n  */\n function _tr_flush_block(s, buf, stored_len, last)\n //DeflateState *s;\n //charf *buf;       /* input block, or NULL if too old */\n //ulg stored_len;   /* length of input block */\n //int last;         /* one if this is the last block for a file */\n {\n   var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n   var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n   /* Build the Huffman trees unless a stored block is forced */\n   if (s.level > 0) {\n\n     /* Check if the file is binary or text */\n     if (s.strm.data_type === Z_UNKNOWN) {\n       s.strm.data_type = detect_data_type(s);\n     }\n\n     /* Construct the literal and distance trees */\n     build_tree(s, s.l_desc);\n     // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n     //        s->static_len));\n\n     build_tree(s, s.d_desc);\n     // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n     //        s->static_len));\n     /* At this point, opt_len and static_len are the total bit lengths of\n      * the compressed block data, excluding the tree representations.\n      */\n\n     /* Build the bit length tree for the above two trees, and get the index\n      * in bl_order of the last bit length code to send.\n      */\n     max_blindex = build_bl_tree(s);\n\n     /* Determine the best encoding. Compute the block lengths in bytes. */\n     opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n     static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n     // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n     //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n     //        s->last_lit));\n\n     if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n   } else {\n     // Assert(buf != (char*)0, \"lost buf\");\n     opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n   }\n\n   if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n     /* 4: two words for the lengths */\n\n     /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n      * Otherwise we can't have processed more than WSIZE input bytes since\n      * the last block flush, because compression would have been\n      * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n      * transform a block into a stored block.\n      */\n     _tr_stored_block(s, buf, stored_len, last);\n\n   } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n     send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n     compress_block(s, static_ltree, static_dtree);\n\n   } else {\n     send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n     send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n     compress_block(s, s.dyn_ltree, s.dyn_dtree);\n   }\n   // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n   /* The above check is made mod 2^32, for files larger than 512 MB\n    * and uLong implemented on 32 bits.\n    */\n   init_block(s);\n\n   if (last) {\n     bi_windup(s);\n   }\n   // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n   //       s->compressed_len-7*last));\n }\n\n /* ===========================================================================\n  * Save the match info and tally the frequency counts. Return true if\n  * the current block must be flushed.\n  */\n function _tr_tally(s, dist, lc)\n //    deflate_state *s;\n //    unsigned dist;  /* distance of matched string */\n //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n {\n   //var out_length, in_length, dcode;\n\n   s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n   s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n   s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n   s.last_lit++;\n\n   if (dist === 0) {\n     /* lc is the unmatched char */\n     s.dyn_ltree[lc * 2]/*.Freq*/++;\n   } else {\n     s.matches++;\n     /* Here, lc is the match length - MIN_MATCH */\n     dist--;             /* dist = match distance - 1 */\n     //Assert((ush)dist < (ush)MAX_DIST(s) &&\n     //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n     //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n     s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n     s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n   }\n\n // (!) This block is disabled in zlib defaults,\n // don't enable it for binary compatibility\n\n //#ifdef TRUNCATE_BLOCK\n //  /* Try to guess if it is profitable to stop the current block here */\n //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n //    /* Compute an upper bound for the compressed length */\n //    out_length = s.last_lit*8;\n //    in_length = s.strstart - s.block_start;\n //\n //    for (dcode = 0; dcode < D_CODES; dcode++) {\n //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n //    }\n //    out_length >>>= 3;\n //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n //    //       s->last_lit, in_length, out_length,\n //    //       100L - out_length*100L/in_length));\n //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n //      return true;\n //    }\n //  }\n //#endif\n\n   return (s.last_lit === s.lit_bufsize - 1);\n   /* We avoid equality with lit_bufsize because of wraparound at 64K\n    * on 16 bit machines and because stored blocks are restricted to\n    * 64K-1 bytes.\n    */\n }\n\n exports._tr_init  = _tr_init;\n exports._tr_stored_block = _tr_stored_block;\n exports._tr_flush_block  = _tr_flush_block;\n exports._tr_tally = _tr_tally;\n exports._tr_align = _tr_align;\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n__tr_init = module.exports._tr_init;\n__tr_stored_block = module.exports._tr_stored_block;\n__tr_flush_block = module.exports._tr_flush_block;\n__tr_tally = module.exports._tr_tally;\n__tr_align = module.exports._tr_align;\n\n}, () => ({\n  '../utils/common': _req,\n}));\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}